<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Arcade+ — Scorched Cats (Worms-like)</title>
<style>
  :root{
    --bg:#0b1020; --bg2:#0e1430; --card:#121932; --ink:#e8ecff; --muted:#aab3d9;
    --line:#233055; --accent:#6ea8fe; --ok:#22c55e; --warn:#f59e0b; --danger:#ef4444;
    --pad:12px; --radius:16px;
  }
  *{box-sizing:border-box}
  html,body{
    margin:0;background:linear-gradient(180deg,var(--bg),var(--bg2));color:var(--ink);
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;height:100%;
    overscroll-behavior:none; overflow:hidden;
  }
  .stage-wrap{position:fixed; inset:0; display:flex; align-items:center; justify-content:center}
  .stage{position:relative; border-radius:14px; border:1px solid var(--line); overflow:hidden; background:#0b1020}
  canvas{display:block; touch-action:manipulation}

  /* HUD root */
  .hud{position:absolute; inset:0; pointer-events:none}
  .hud *{pointer-events:auto}

  /* Top bar */
  .topbar{
    position:absolute; left:10px; right:10px; top:10px;
    display:flex; gap:10px; align-items:center; justify-content:space-between;
    background:rgba(18,25,50,.85); backdrop-filter: blur(6px);
    border:1px solid var(--line); border-radius:999px; padding:6px 10px; z-index:35;
    font-size:14px;
  }
  .topbar .left,.topbar .mid,.topbar .right{display:flex; align-items:center; gap:10px}
  .chip{padding:4px 10px; border:1px solid var(--line); border-radius:999px; background:#0f1633}
  .chip.phase{display:flex; gap:8px; align-items:center}
  .small{color:var(--muted);font-size:12px}
  .meter{position:relative; width:120px; height:8px; background:#1a2346; border-radius:99px; overflow:hidden}
  .meter .left,.meter .right{position:absolute; top:0; height:100%}
  .meter .left{right:50%; background:#6ea8fe;}
  .meter .right{left:50%; background:#ef4444;}
  .meter .mid{position:absolute; left:50%; top:-2px; bottom:-2px; width:2px; background:#27335f; transform:translateX(-1px); border-radius:99px}

  /* Bottom dock */
  .dock{
    position:absolute; left:10px; right:10px; bottom:10px;
    display:grid; grid-template-columns:auto 1fr auto; gap:10px; align-items:center;
    background:rgba(18,25,50,.85); backdrop-filter: blur(6px);
    border:1px solid var(--line); border-radius:16px; padding:10px;
  }
  .btn{appearance:none;border:1px solid var(--line);background:var(--accent);color:#081225;
    font-weight:700;border-radius:12px;padding:10px 14px;cursor:pointer}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .weaponBadge{
    border:1px solid var(--line); background:#0f1633; color:#e8ecff;
    padding:8px 12px; border-radius:999px; cursor:pointer; user-select:none;
    display:flex; align-items:center; gap:8px; min-width:150px
  }
  .weaponMenu{
    position:absolute; bottom:58px; left:10px;
    background:rgba(18,25,50,.95); border:1px solid var(--line); border-radius:12px; padding:6px;
    display:none; flex-direction:column; gap:6px; z-index:40; min-width:210px
  }
  .weaponMenu .opt{
    padding:8px 10px; border-radius:8px; cursor:pointer; display:flex; align-items:center; justify-content:space-between;
    border:1px solid transparent; gap:10px
  }
  .weaponMenu .opt:hover{ background:#0f1633; border-color:#2a3560; }
  .weaponMenu .opt.active{ background:#a78bfa; color:#081225; border-color:#a78bfa; }
  .ammoPips{font-size:12px;color:var(--muted)}
  .fuseChip{border:1px solid var(--line); padding:2px 6px; border-radius:999px; font-size:12px; background:#141c3a; cursor:pointer}

  .fireWrap{position:relative; display:flex; align-items:center; justify-content:center}
  .fireBtn{ width:100%; min-height:44px; }
  .chargeBar{
    position:absolute; left:10px; right:10px; bottom:6px; height:3px;
    background:linear-gradient(90deg,#22c55e,#f59e0b,#ef4444);
    width:0%; border-radius:99px; transition:width .06s linear; pointer-events:none;
  }

  .zoomRow{display:flex; gap:8px}
  .zoomRow .btn{min-width:44px}

  /* Left movement joystick + jump */
  .joyWrap{
    position:absolute; left:10px; bottom:92px; width:120px; height:120px;
    background:rgba(18,25,50,.55); border:1px solid var(--line); border-radius:50%; z-index:30;
    touch-action:none; user-select:none;
  }
  .joyBase{position:absolute; inset:8px; border-radius:50%; background:#0f1633; border:1px solid #25355f}
  .joyKnob{position:absolute; width:56px; height:56px; border-radius:50%;
    background:#20305c; border:1px solid #3a4f8a; left:50%; top:50%; transform:translate(-50%,-50%)}
  .jumpBtn{
    position:absolute; left:144px; bottom:130px; min-width:56px;
    background:#ffd166; color:#1a1f2f; border:1px solid var(--line); border-radius:14px; padding:10px 14px; font-weight:800; z-index:31;
  }

  /* Menu panel */
  .menuPanel{
    position:absolute; top:60px; left:50%; transform:translateX(-50%);
    width:min(92%,820px); background:rgba(10,14,30,.92); border:1px solid var(--line); border-radius:16px; padding:14px; display:none; z-index:50;
    max-height:calc(100vh - 90px); overflow:auto; -webkit-overflow-scrolling:touch;
  }

  @media (max-width: 820px){
  .menuPanel{
    max-height: 70vh;        /* requested cap on small screens */
    overflow-y: auto;         /* vertical scroll inside the panel */
    -webkit-overflow-scrolling: touch;
  }
}
  
  .menuGrid{display:grid; grid-template-columns:1fr 1fr; gap:14px}
  .menuRow{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:6px 0}
  .menuRow > * {font-size:14px}
  .sel, .chk, .txt{
    appearance:none; background:#0f1633; color:#e8ecff; border:1px solid var(--line); border-radius:10px; padding:8px 10px
  }
  .chk{appearance:auto; accent-color:#6ea8fe; width:auto}
  .miniPreview{border:1px solid var(--line); border-radius:12px; overflow:hidden; background:#0b1020}
  .miniBar{display:flex; gap:8px; margin-top:8px; align-items:center}
  .miniBtn{padding:6px 10px; border:1px solid var(--line); background:#141c3a; border-radius:8px; cursor:pointer}

  /* Winner banner */
  .banner{
    position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:60;
    background:rgba(0,0,0,.35); backdrop-filter:blur(4px)
  }
  .card{
    background:rgba(18,25,50,.95); border:1px solid var(--line); border-radius:16px; padding:18px; min-width:280px; text-align:center
  }
  .stats{color:var(--muted); font-size:13px; margin:8px 0 12px}
  .card .btn{margin:0 6px}

  /* Nameplates */
  .nameplate{position:absolute; transform:translate(-50%, -100%); background:rgba(18,25,50,.9); border:1px solid var(--line);
    padding:2px 8px; border-radius:999px; font-size:12px; pointer-events:none}

  /* Rotate overlay */
  .rotate{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:linear-gradient(180deg,var(--bg),var(--bg2)); z-index:1000; text-align:center; padding:24px;
  }
  .rotate .box{
    background:rgba(18,25,50,.93); border:1px solid var(--line); border-radius:14px; padding:16px 18px; max-width:360px;
  }
  @media (orientation:portrait){ .rotate{display:flex} }
  @media (max-width:800px){ .menuGrid{grid-template-columns:1fr} }
</style>
</head>
<body>
<div class="rotate"><div class="box">
  <div style="font-weight:700; margin-bottom:6px">Please rotate your device</div>
  <div class="small">This game is best experienced in landscape.</div>
</div></div>

<div class="stage-wrap">
  <div class="stage" id="stage">
    <canvas id="c" width="900" height="520"></canvas>

    <!-- HUD -->
    <div class="hud" id="hud">
      <!-- Top bar: Menu • Phase • Turn • Wind -->
      <div class="topbar">
        <div class="left">
          <button id="menuBtn" class="btn" style="padding:6px 12px; font-weight:700">Menu</button>
          <span class="chip phase"><span id="phaseLabel">Move</span> <span id="phaseTimer" class="small">30s</span></span>
        </div>
        <div class="mid">
          <span class="chip">Turn: <strong id="turn">P1</strong></span>
        </div>
        <div class="right">
          <div class="small" id="windLabel">Wind</div>
          <div class="meter" title="Wind: left ⟵ 0 ⟶ right">
            <div id="windL" class="left"></div>
            <div id="windR" class="right"></div>
            <div class="mid"></div>
          </div>
          <div class="small" id="windVal">→ 0</div>
        </div>
      </div>

      <!-- Bottom Dock -->
      <div class="dock">
        <div style="position:relative">
          <div id="weaponBadge" class="weaponBadge" aria-haspopup="true" aria-expanded="false">
            <span id="weaponEmoji">🚀</span><span id="weaponName">Bazooka</span>
            <span id="weaponMeta" class="small"></span><span>⌄</span>
          </div>
          <div id="weaponMenu" class="weaponMenu" role="menu" aria-label="Select weapon">
            <div class="opt active" data-w="normal"><span>🚀 Bazooka</span><span class="ammoPips" id="pipNormal">∞</span></div>
            <div class="opt" data-w="grenade"><span>💣 Grenade <span id="fuseMini" class="small">⏱5s</span></span><span class="ammoPips" id="pipGrenade">x5</span></div>
            <div class="opt" data-w="shotgun"><span>🔫 Shotgun</span><span class="ammoPips" id="pipShotgun">x5</span></div>
            <div class="opt" data-w="drill"><span>🛠️ Drill</span><span class="ammoPips" id="pipDrill">x2</span></div>
            <div class="opt" data-w="teleport"><span>🌀 Teleport</span><span class="ammoPips" id="pipTeleport">x1</span></div>
          </div>
        </div>

        <div class="fireWrap">
          <button id="fire" class="btn fireBtn">HOLD TO FIRE 🔥</button>
          <div id="chargeBar" class="chargeBar"></div>
        </div>

        <div class="zoomRow">
          <button id="zoomIn" class="btn" title="Zoom In">＋</button>
          <button id="zoomOut" class="btn" title="Zoom Out">－</button>
        </div>
      </div>

      <!-- Movement joystick + jump -->
      <div class="joyWrap" id="joyWrap" aria-label="Move">
        <div class="joyBase"></div>
        <div class="joyKnob" id="joyKnob"></div>
      </div>
      <button class="jumpBtn" id="jumpBtn" title="Jump">⤴︎ Jump</button>
    </div>

    <!-- Menu Panel -->
    <div class="menuPanel" id="menuPanel">
      <div class="menuGrid">
        <div>
          <div class="menuRow"><span>Mode</span>
            <select id="modeSel" class="sel">
              <option value="pvp">🧍‍♂️ Player vs Player</option>
              <option value="pvc">🤖 Player vs Computer</option>
            </select>
          </div>
          <div class="menuRow"><span>Difficulty</span>
            <select id="diffSel" class="sel">
              <option>Easy</option><option selected>Medium</option><option>Hard</option>
            </select>
          </div>
          <div class="menuRow"><span>Turn time</span>
            <select id="turnSel" class="sel">
              <option>10</option><option>20</option><option selected>30</option><option>40</option><option>60</option><option>90</option>
            </select>
          </div>
          <div class="menuRow"><span>Retreat time</span>
            <select id="retSel" class="sel">
              <option selected>0</option>
              <option>3</option>
              <option>5</option>
              <option>8</option>
              <option>10</option>
            </select>
          </div>
          <div class="menuRow"><span>Wind</span>
            <select id="windSel" class="sel">
              <option>Off</option><option>Low</option><option selected>Normal</option><option>High</option>
            </select>
          </div>
          <div class="menuRow"><span>Fall damage</span>
            <label><input id="fallChk" class="chk" type="checkbox" checked> On</label>
          </div>
          <div class="menuRow"><span>Ammo limits</span>
            <label><input id="ammoChk" class="chk" type="checkbox" checked> On</label>
          </div>
          <div class="menuRow"><span>Different levels spawn</span>
            <label><input id="levelsChk" class="chk" type="checkbox" checked> On</label>
          </div>
          <div class="menuRow"><span>Weapons</span>
            <div>
              <label style="margin-right:8px"><input id="wShotgun" class="chk" type="checkbox" checked> 🔫</label>
              <label style="margin-right:8px"><input id="wGrenade" class="chk" type="checkbox" checked> 💣</label>
              <label style="margin-right:8px"><input id="wDrill" class="chk" type="checkbox" checked> 🛠️</label>
              <label><input id="wTeleport" class="chk" type="checkbox" checked> 🌀</label>
            </div>
          </div>
          <div class="menuRow"><span>Map seed</span>
            <input id="seedTxt" class="txt" placeholder="random" maxlength="12" />
          </div>
        </div>
        <div>
          <div class="small">Map preview</div>
          <div class="miniPreview"><canvas id="mini" width="160" height="92"></canvas></div>
          <div class="miniBar">
            <button id="newMapBtn" class="miniBtn">🔁 New Map</button>
            <span class="small">Tip: long-press preview for custom seed</span>
          </div>
        </div>
      </div>
      <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:12px">
        <button id="startBtn" class="btn">▶ Start Match</button>
        <button id="closeMenu" class="btn" style="background:#141c3a;color:var(--ink)">Close</button>
      </div>
    </div>

    <!-- Winner banner -->
    <div class="banner" id="banner">
      <div class="card">
        <div id="winTxt" style="font-weight:800;font-size:18px;margin-bottom:6px">P1 wins 🎉</div>
        <div class="stats" id="statsTxt">Shots: 0 · Accuracy: 0% · Biggest hit: 0</div>
        <div>
          <button id="rematchBtn" class="btn">Rematch</button>
          <button id="newMapBannerBtn" class="btn" style="background:#a78bfa">New Map</button>
          <button id="openMenuBtn" class="btn" style="background:#141c3a;color:var(--ink)">Menu</button>
        </div>
      </div>
    </div>

    <!-- Nameplates -->
    <div id="np1" class="nameplate">P1 — 100%</div>
    <div id="np2" class="nameplate">P2 — 100%</div>
  </div>
</div>

<script>
(()=> {
  // ======= Canvas & fit =======
  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d');
  const stage = document.getElementById('stage');
  const W = cvs.width, H = cvs.height;

  function fitCanvas(){
    const vw = window.innerWidth, vh = window.innerHeight;
    const scale = Math.min(vw / W, vh / H);
    const cssW = Math.round(W * scale), cssH = Math.round(H * scale);
    cvs.style.width = cssW + 'px';
    cvs.style.height = cssH + 'px';
    stage.style.width = cssW + 'px';
    stage.style.height = cssH + 'px';
  }
  window.addEventListener('resize', fitCanvas);
  window.addEventListener('orientationchange', fitCanvas);
  fitCanvas();

  cvs.addEventListener('touchmove', (e)=>{ e.preventDefault(); }, {passive:false});
  document.addEventListener('dblclick', e => { if (stage.contains(e.target)) e.preventDefault(); }, {passive:false});

  // ======= Physics & constants =======
  const G = 0.20;
  let WIND_MAX = 0.05;
  const EXPLOSION_R = 34;
  const PLAYER_R = 16;
  const SKY = 0, SOLID = 1;
  const FALL_NO_DMG = 60;

  // ======= HUD refs =======
  const turnEl  = document.getElementById('turn');
  const windL   = document.getElementById('windL');
  const windR   = document.getElementById('windR');
  const windVal = document.getElementById('windVal');

  const weaponBadge = document.getElementById('weaponBadge');
  const weaponMenu  = document.getElementById('weaponMenu');
  const weaponName  = document.getElementById('weaponName');
  const weaponEmoji = document.getElementById('weaponEmoji');
  const weaponMeta  = document.getElementById('weaponMeta');
  const pipGrenade  = document.getElementById('pipGrenade');
  const pipShotgun  = document.getElementById('pipShotgun');
  const pipTeleport = document.getElementById('pipTeleport');
  const pipNormal   = document.getElementById('pipNormal');
  const pipDrill    = document.getElementById('pipDrill');
  const fuseMini    = document.getElementById('fuseMini');

  const fireBtn = document.getElementById('fire');
  const chargeBar = document.getElementById('chargeBar');
  const zoomIn  = document.getElementById('zoomIn');
  const zoomOut = document.getElementById('zoomOut');
  const banner = document.getElementById('banner');
  const winTxt = document.getElementById('winTxt');
  const statsTxt = document.getElementById('statsTxt');
  const rematchBtn = document.getElementById('rematchBtn');
  const newMapBannerBtn = document.getElementById('newMapBannerBtn');
  const openMenuBtn = document.getElementById('openMenuBtn');
  const np1 = document.getElementById('np1');
  const np2 = document.getElementById('np2');

  // Phase UI
  const phaseLabel = document.getElementById('phaseLabel');
  const phaseTimer = document.getElementById('phaseTimer');

  // Menu
  const menuBtn = document.getElementById('menuBtn');
  const menuPanel = document.getElementById('menuPanel');
  const modeSel = document.getElementById('modeSel');
  const diffSel = document.getElementById('diffSel');
  const windSel = document.getElementById('windSel');
  const fallChk = document.getElementById('fallChk');
  const ammoChk = document.getElementById('ammoChk');
  const levelsChk = document.getElementById('levelsChk');
  const wShotgun = document.getElementById('wShotgun');
  const wGrenade = document.getElementById('wGrenade');
  const wTeleport = document.getElementById('wTeleport');
  const wDrill = document.getElementById('wDrill');
  const turnSel = document.getElementById('turnSel');
  const retSel = document.getElementById('retSel'); // <-- add this line here
  const seedTxt = document.getElementById('seedTxt');
  const startBtn = document.getElementById('startBtn');
  const newMapBtn = document.getElementById('newMapBtn');
  const closeMenu = document.getElementById('closeMenu');
  const mini = document.getElementById('mini');
  const miniCtx = mini.getContext('2d');

  // Movement controls
  const joyWrap = document.getElementById('joyWrap');
  const joyKnob = document.getElementById('joyKnob');
  const jumpBtn = document.getElementById('jumpBtn');

  // ======= Audio =======
  let audioCtx = null, chargeOsc=null, chargeGain=null;
  function audio(){ if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); return audioCtx; }
  function tone(freq=200, dur=0.1, type='square', gain=0.18){
    const ctx = audio(); const t=ctx.currentTime;
    const o=ctx.createOscillator(), g=ctx.createGain();
    o.type=type; o.frequency.value=f; o.connect(g); g.connect(ctx.destination);
    g.gain.setValueAtTime(gain, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+dur);
    o.start(t); o.stop(t+dur);
  }
  function noiseBoom(dur=0.35, startGain=0.35){
    const ctx = audio(); const t=ctx.currentTime;
    const buffer = ctx.createBuffer(1, ctx.sampleRate*dur, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i]= (Math.random()*2-1) * (1-i/data.length);
    const src = ctx.createBufferSource(); src.buffer=buffer;
    const g=ctx.createGain(); g.gain.setValueAtTime(startGain,t);
    g.gain.exponentialRampToValueAtTime(0.001, t+dur);
    src.connect(g); g.connect(ctx.destination); src.start(t);
  }
  function taDa(){ const ctx=audio(), t=ctx.currentTime, seq=[440,660,880];
    seq.forEach((f,i)=>{ const o=ctx.createOscillator(), g=ctx.createGain();
      o.type='triangle'; o.frequency.value=f; o.connect(g); g.connect(ctx.destination);
      g.gain.setValueAtTime(0.25, t+0.09*i);
      g.gain.exponentialRampToValueAtTime(0.001, t+0.09*i+0.25);
      o.start(t+0.09*i); o.stop(t+0.09*i+0.25);
    });
  }
  function whoosh(){ const ctx=audio(), t=ctx.currentTime;
    const o=ctx.createOscillator(), g=ctx.createGain(); o.type='sine';
    o.frequency.setValueAtTime(220,t); o.frequency.exponentialRampToValueAtTime(740,t+0.18);
    g.gain.setValueAtTime(0.18,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.2);
    o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t+0.22);
  }
  function poof(){ const ctx=audio(), t=ctx.currentTime;
    const o=ctx.createOscillator(), g=ctx.createGain(); o.type='sine';
    o.frequency.setValueAtTime(600,t); o.frequency.exponentialRampToValueAtTime(240,t+0.15);
    g.gain.setValueAtTime(0.18,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.16);
    o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t+0.18);
  }
  function haptics(p=[40]){ if (navigator.vibrate) navigator.vibrate(p); }
  function startChargeSound(){
    const ctx = audio();
    chargeOsc = ctx.createOscillator(); chargeGain = ctx.createGain();
    chargeOsc.type = 'sawtooth'; chargeOsc.frequency.setValueAtTime(220, ctx.currentTime);
    chargeGain.gain.setValueAtTime(0.08, ctx.currentTime);
    chargeOsc.connect(chargeGain); chargeGain.connect(ctx.destination); chargeOsc.start();
  }
  function updateChargeSound(pct){
    if (!chargeOsc) return; const ctx=audio(); const f=220 + pct*520;
    chargeOsc.frequency.linearRampToValueAtTime(f, ctx.currentTime + 0.05);
  }
  function stopChargeSound(){
    if (!chargeOsc) return; const ctx=audio(); const o=chargeOsc, g=chargeGain;
    chargeOsc=null; chargeGain=null; if (g) g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+0.08);
    if (o) o.stop(ctx.currentTime+0.1);
  }

  // ======= RNG & terrain buffers =======
  let seed = Math.random().toString(36).slice(2,8);
  function srand(s){ seed = s || Math.random().toString(36).slice(2,8); }
  function rand(){ let x = 0; for (let i=0;i<seed.length;i++) x = (x*31 + seed.charCodeAt(i))>>>0;
    x ^= x<<13; x ^= x>>>17; x ^= x<<5; x>>>=0; seed = (x>>>0).toString(36).slice(0,6); return (x%1e9)/1e9; }

  let cam = { scale: 1, targetScale: 1, min:0.85, max:1.8 };
  const terrCanvas = document.createElement('canvas'); terrCanvas.width=W; terrCanvas.height=H;
  const terrCtx = terrCanvas.getContext('2d');
  const decalCanvas = document.createElement('canvas'); decalCanvas.width=W; decalCanvas.height=H;
  const decalCtx = decalCanvas.getContext('2d');
  let terrainMask = new Uint8Array(W*H);
  let heightmap = new Int16Array(W);

  // ======= Players, weapons, shots =======
  const Weapons = { NORMAL:'normal', GRENADE:'grenade', SHOTGUN:'shotgun', DRILL:'drill', TELEPORT:'teleport' };
  const EMOJI = { normal:'🚀', grenade:'💣', shotgun:'🔫', drill:'🛠️', teleport:'🌀' };

  const players = [
    { name:'P1', emoji:'😼', color:'#6ea8fe', x:0, y:0, vx:0, vy:0, hp:100, angle:45, facing:1,
      emote:null, emoteT:0, lastPower:50, lastWeapon:Weapons.NORMAL, fuse:5,
      ammo:{ shotgun:5, grenade:5, drill:2, teleport:1 } },
    { name:'P2', emoji:'😺', color:'#90c2ff', x:0, y:0, vx:0, vy:0, hp:100, angle:135, facing:-1,
      emote:null, emoteT:0, lastPower:50, lastWeapon:Weapons.NORMAL, fuse:5,
      ammo:{ shotgun:5, grenade:5, drill:2, teleport:1 } }
  ];
  let turn = 0;
  let wind = 0;
  let weapon = Weapons.NORMAL;
  let aiEnabled = false;

  // Timers/phases
  let turnSeconds = 30;
  let phase = 'move'; // 'move' | 'aim' (implicit) | 'retreat'
  let phaseTimeLeft = 30;
  let retreatSeconds = 0;  // default 0s, can be changed via menu

  // Movement joystick state
  let joyActive=false, joyDX=0, joyDY=0, joyCenter=null, joyRadius=44;
  let jumpQueued=false;

  // Shots & FX
  let shot = null;
  let particles = [];
  let rings = [];
  let dmgNums = [];
  const stats = { shots:[0,0], hits:[0,0], bestHit:[0,0] };
  let placingTeleport = false;
  let grenadeFuse = 5;

  // ======= Terrain generation =======
  function generateTerrain(){
    terrCtx.clearRect(0,0,W,H);
    decalCtx.clearRect(0,0,W,H);
    terrainMask.fill(SKY); heightmap.fill(H);

    const base = new Float32Array(W);
    let y = H*0.55 + (rand()*80-40); let dy = 0;
    for(let x=0;x<W;x++){ dy += (rand()-0.5)*2; dy*=0.95; y += dy; base[x]=y; }
    const smooth = new Float32Array(W);
    const K=14; let acc=0;
    for(let x=0;x<W+K;x++){ if(x<W) acc+=base[x]; if(x>=K) acc-=base[x-K];
      if(x>=K-1) smooth[x-(K-1)] = acc/Math.min(x+1,K,W);
    }
    for(let x=0;x<W;x++){
      let yy = smooth[x] + Math.sin(x*0.01)*14 + Math.sin(x*0.053)*8;
      yy = Math.max(H*0.35, Math.min(H*0.85, yy));
      heightmap[x] = Math.floor(yy);
    }
    const img = terrCtx.getImageData(0,0,W,H);
    const d = img.data;
    for(let x=0;x<W;x++){
      for(let y=heightmap[x]|0;y<H;y++){
        const idx = y*W+x; terrainMask[idx]=SOLID; const p=idx*4;
        d[p]=24; d[p+1]=32; d[p+2]=58; d[p+3]=255;
      }
    }
    terrCtx.putImageData(img,0,0);
    terrCtx.strokeStyle = '#2ecc71'; terrCtx.lineWidth=2; terrCtx.beginPath();
    for(let x=0;x<W;x++) terrCtx.lineTo(x+0.5, heightmap[x]-1.5);
    terrCtx.stroke();

    placePlayers();
    randomizeWind();
    drawMiniPreview();
  }

  function placePlayers(){
    function findSurfaceX(x0,x1){
      for(let tries=0;tries<500;tries++){
        const x = Math.floor(x0 + rand()*(x1-x0));
        const y = heightmap[x]-PLAYER_R;
        if (y>0 && y<H-PLAYER_R){
          const left = heightmap[Math.max(0,x-6)];
          const right= heightmap[Math.min(W-1,x+6)];
          if (Math.abs(left-right) < 20) return {x,y};
        }
      }
      return {x:Math.floor((x0+x1)/2), y:heightmap[Math.floor((x0+x1)/2)]-PLAYER_R};
    }
    const a=findSurfaceX(40, W/2-80);
    let b=findSurfaceX(W/2+80, W-40);

    if (levelsChk.checked){
      // ensure significantly different elevations
      let tries=0;
      while (tries++<400 && Math.abs((heightmap[a.x]||a.y) - (heightmap[b.x]||b.y)) < 60){
        b=findSurfaceX(W/2+80, W-40);
      }
    }

    Object.assign(players[0], {x:a.x, y:a.y, vx:0, vy:0, facing:1, angle:45});
    Object.assign(players[1], {x:b.x, y:b.y, vx:0, vy:0, facing:-1, angle:135});
  }

  // ======= Damage helpers =======
  function floatDmg(x,y,val){ dmgNums.push({x,y,val,life:40}); }
  function applyDamage(index, dmg, direct=false){
    const pl = players[index];
    pl.hp = Math.max(0, pl.hp - dmg);
    updateHPPlates();
    if (pl.hp<=0){ announceWinner(1-index, direct ? 'direct hit!' : 'boom!'); }
  }

  // Splash with cap option
  function applySplashDamageCapped(cx,cy,r, capPerShot=999){
    // We’ll accumulate per-target this explosion and clamp to capPerShot
    const dealt=[0,0];
    for(let i=0;i<players.length;i++){
      const pl=players[i]; const dx=pl.x-cx, dy=pl.y-cy;
      const d2=dx*dx+dy*dy, r2=r*r;
      if (d2<r2){
        const d=Math.sqrt(d2), scale=Math.max(0,1-d/r);
        let dmg=Math.round(scale*60); // base model
        if (capPerShot < 999){
          const can = Math.max(0, capPerShot - dealt[i]);
          dmg = Math.min(dmg, can);
        }
        if (dmg>0){ applyDamage(i,dmg,false); floatDmg(pl.x, pl.y-PLAYER_R-8, -dmg); dealt[i]+=dmg; stats.bestHit[turn]=Math.max(stats.bestHit[turn], dmg); stats.hits[turn]++; }
        const k = 3.4*scale;
        const len = Math.max(1, Math.hypot(dx,dy));
        const nx = dx/len, ny = dy/len;
        pl.vx += nx * k; pl.vy += ny * k - 0.3;
      }
    }
  }

  function announceWinner(idx, reason){
    fireBtn.disabled=true; placingTeleport=false;
    turnEl.textContent=`P${idx+1} wins 🎉`;
    players[idx].emote='😼✨'; players[idx].emoteT=120;
    players[1-idx].emote='💀'; players[1-idx].emoteT=120;
    taDa(); haptics([60,60,60]);
    showWinBanner(idx, reason);
    confettiBurst();
  }

  // ======= Weapons =======
  function displayName(w){ return w==='normal' ? 'Bazooka' : (w.charAt(0).toUpperCase()+w.slice(1)); }

  function updateBadge(){
    const p = players[turn];
    weaponEmoji.textContent = EMOJI[weapon];
    weaponName.textContent = displayName(weapon);
    let meta = '';
    if (weapon==='grenade') meta += ` ⏱${p.fuse||grenadeFuse}s`;
    const am = p.ammo;
    const left = (weapon==='shotgun')?am.shotgun : weapon==='grenade'?am.grenade : weapon==='teleport'?am.teleport : weapon==='drill'?am.drill : Infinity;
    if (left!==Infinity) meta += ` (${left>0?'x'+left:'empty'})`;
    weaponMeta.textContent = meta;

    fuseMini.textContent = `⏱${p.fuse||grenadeFuse}s`;
    pipNormal.textContent = '∞';
    pipGrenade.textContent = 'x'+ am.grenade;
    pipShotgun.textContent = 'x'+ am.shotgun;
    pipTeleport.textContent = 'x'+ am.teleport;
    pipDrill.textContent   = 'x'+ am.drill;

    refreshWeaponOptions();
    [...weaponMenu.querySelectorAll('.opt')].forEach(o=>o.classList.toggle('active', o.dataset.w===weapon));
  }

  function refreshWeaponOptions(){
    const p = players[turn];
    const setVis = (key, show)=>{ const el = weaponMenu.querySelector(`[data-w="${key}"]`); if (el) el.style.display = show ? 'flex':'none'; }
    setVis('grenade', p.ammo.grenade>0 && wGrenade.checked);
    setVis('shotgun', p.ammo.shotgun>0 && wShotgun.checked);
    setVis('teleport', p.ammo.teleport>0 && wTeleport.checked);
    setVis('drill',   p.ammo.drill>0   && wDrill.checked);
    if ((weapon==='grenade' && (!wGrenade.checked || p.ammo.grenade<=0)) ||
        (weapon==='shotgun' && (!wShotgun.checked || p.ammo.shotgun<=0)) ||
        (weapon==='teleport' && (!wTeleport.checked || p.ammo.teleport<=0)) ||
        (weapon==='drill'   && (!wDrill.checked   || p.ammo.drill<=0))){
      weapon='normal';
      players[turn].lastWeapon = weapon;
    }
  }
  function ensureAmmoOrSwitch(){
    const p=players[turn], am=p.ammo;
    if (weapon==='shotgun' && am.shotgun<=0) weapon='normal';
    if (weapon==='grenade' && am.grenade<=0) weapon='normal';
    if (weapon==='teleport' && am.teleport<=0) weapon='normal';
    if (weapon==='drill'   && am.drill<=0)   weapon='normal';
    players[turn].lastWeapon = weapon; updateBadge();
  }
  function spendAmmo(){
    const p=players[turn], am=p.ammo;
    if (weapon==='shotgun') am.shotgun = Math.max(0, am.shotgun - 1);
    if (weapon==='grenade') am.grenade = Math.max(0, am.grenade - 1);
    if (weapon==='teleport') am.teleport = Math.max(0, am.teleport - 1);
    if (weapon==='drill')   am.drill   = Math.max(0, am.drill   - 1);
    if ((weapon==='shotgun' && am.shotgun===0) ||
        (weapon==='grenade' && am.grenade===0) ||
        (weapon==='teleport' && am.teleport===0) ||
        (weapon==='drill'   && am.drill===0)){
      toast(`${displayName(weapon)} out — switched to Bazooka`);
      weapon='normal';
      players[turn].lastWeapon = weapon;
    }
    updateBadge();
  }

  function muzzleFrom(p, ang){
    return { x: p.x + Math.cos(ang)*(PLAYER_R+6), y: p.y - Math.sin(ang)*(PLAYER_R+6) };
  }

  function launchShot(power){
    const p = players[turn]; stats.shots[turn]++;
    const ang = (p.angle*Math.PI)/180;
    const {x:muzzleX,y:muzzleY} = muzzleFrom(p, ang);
    const v = Math.max(1, power)*0.9;

    if (weapon==='normal'){
      const vx = Math.cos(ang)*v, vy = -Math.sin(ang)*v;
      shot = { kind:'normal', x:muzzleX, y:muzzleY, vx, vy, trail:[], cap:50 }; // cap 50
      tone(320,0.06,'square',0.18); spendAmmo(); enterRetreat();
    } else if (weapon==='grenade'){
      const vx = Math.cos(ang)*v, vy = -Math.sin(ang)*v;
      const fuse = (players[turn].fuse||grenadeFuse);
      shot = { kind:'grenade', x:muzzleX, y:muzzleY, vx, vy, trail:[], t: fuse*60 };
      tone(260,0.06,'triangle',0.12); spendAmmo(); enterRetreat();
    } else if (weapon==='shotgun'){
      const pellets=[]; const spread = Math.PI/28; const n=7;
      for(let i=0;i<n;i++){
        const offset = (i-(n-1)/2)/(n-1) * spread;
        const a = ang + offset;
        const speed = v*(0.9+Math.random()*0.2);
        pellets.push({ x:muzzleX, y:muzzleY, vx:Math.cos(a)*speed, vy:-Math.sin(a)*speed, trail:[] });
      }
      shot = { kind:'shotgun', pellets, totalHit:[0,0], cap:50, pelletDmg:7 }; // 7*7=49 approx; cap 50
      tone(480,0.05,'square',0.12); setTimeout(()=>tone(420,0.05,'square',0.11),40); setTimeout(()=>tone(360,0.05,'square',0.1),80);
      spendAmmo(); enterRetreat();
    } else if (weapon==='drill'){
      const vx = Math.cos(ang)*(v*0.8), vy = -Math.sin(ang)*(v*0.8);
      shot = { kind:'drill', x:muzzleX, y:muzzleY, vx, vy, life:160, r:10 }; // ~2.6s
      tone(300,0.08,'sawtooth',0.12); spendAmmo(); enterRetreat();
    }
    haptics([25]); fireBtn.disabled=true;
  }

  function spawnExplosionCapped(x,y,r, cap=999){
    carveCrater(x,y,r);
    applySplashDamageCapped(x,y,r,cap);
    const count = 28;
    for(let i=0;i<count;i++){
      const a=Math.random()*Math.PI*2, sp = 1.5+Math.random()*3.5;
      particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-2.0,life:50,smoke:false});
    }
    for(let i=0;i<16;i++){
      const a=(Math.random()*Math.PI) - Math.PI/2;
      const sp = .5+Math.random()*1.3;
      particles.push({x,y,vx:Math.cos(a)*sp*0.6,vy:Math.sin(a)*sp-0.8,life:70,smoke:true, alpha:0.5});
    }
    rings.push({x,y,r:8,alpha:0.35});
    noiseBoom(0.35,0.35); haptics([40,60,40]);
  }

  function stepShot(){
    if (!shot) return;

    if (shot.kind==='normal'){
      const s=shot;
      // swept movement to avoid tunneling
      s.vx += wind; s.vy += G;
      let steps = Math.ceil(Math.max(Math.abs(s.vx), Math.abs(s.vy)));
      steps = Math.max(1, Math.min(steps, 8));
      for (let it=0; it<steps; it++){
        s.x += s.vx/steps; s.y += s.vy/steps;
        if (s.x<0 || s.x>=W || s.y>=H){ endShot(null); return; }
        const ix=s.x|0, iy=s.y|0;
        const opp = players[1-turn];
        const dx=s.x-opp.x, dy=s.y-opp.y;
        if (dx*dx + dy*dy <= (PLAYER_R*PLAYER_R)*0.9){
          floatDmg(opp.x, opp.y-PLAYER_R-8, 'hit');
          spawnExplosionCapped(s.x,s.y,EXPLOSION_R, 50);
          endShot(opp); return;
        }
        if (ix>=0 && ix<W && iy>=0 && iy<H && terrainMask[iy*W+ix]===SOLID){
          spawnExplosionCapped(s.x,s.y,EXPLOSION_R, 50);
          endShot({terrain:true}); return;
        }
      }
      s.trail.push({x:s.x,y:s.y}); if (s.trail.length>200) s.trail.shift();
    }

    if (shot.kind==='grenade'){
      const s=shot;
      s.vy += G; // ignores wind
      let steps = Math.ceil(Math.max(Math.abs(s.vx), Math.abs(s.vy)));
      steps = Math.max(1, Math.min(steps, 8));
      for (let it=0; it<steps; it++){
        s.x += s.vx/steps; s.y += s.vy/steps;
        s.t--; if (s.t<=0){ spawnExplosionCapped(s.x,s.y,EXPLOSION_R*1.05, 999); endShot({terrain:true}); return; }
        if (s.x<0 || s.x>=W || s.y>=H){ endShot(null); return; }
        const ix=s.x|0, iy=s.y|0;
        if (ix>=0 && ix<W && iy>=0 && iy<H && terrainMask[iy*W+ix]===SOLID){
          // simple bounce
          const gx = (heightmap[Math.min(W-1,ix+1)] - heightmap[Math.max(0,ix-1)])*0.5;
          let nx = -gx; let ny = 2;
          const len = Math.max(1, Math.hypot(nx,ny)); nx/=len; ny/=len;
          const dot = s.vx*nx + s.vy*ny;
          s.vx = (s.vx - 2*dot*nx) * 0.92;
          s.vy = (s.vy - 2*dot*ny) * 0.68;
          tone(180,0.04,'square',0.12);
          let c=0; while((terrainMask[(s.y|0)*W+(s.x|0)]===SOLID) && c++<6){ s.y-=1; }
        }
      }
      s.trail.push({x:s.x,y:s.y}); if (s.trail.length>140) s.trail.shift();
    }

    if (shot.kind==='shotgun'){
      const pellets = shot.pellets;
      for (let k=pellets.length-1;k>=0;k--){
        const p=pellets[k];
        p.vx += wind; p.vy += G; p.x += p.vx; p.y += p.vy;
        p.trail.push({x:p.x,y:p.y}); if (p.trail.length>80) p.trail.shift();
        if (p.x<0 || p.x>=W || p.y>=H){ pellets.splice(k,1); continue; }
        const ix=p.x|0, iy=p.y|0;
        // player hit
        for (let i=0;i<2;i++){
          const opp = players[i];
          const dx=p.x-opp.x, dy=p.y-opp.y;
          if (dx*dx+dy*dy <= (PLAYER_R*PLAYER_R)*0.85){
            const can = Math.max(0, shot.cap - shot.totalHit[i]);
            const dmg = Math.min(shot.pelletDmg, can);
            if (dmg>0){
              applyDamage(i,dmg,true);
              floatDmg(opp.x, opp.y-PLAYER_R-8, -dmg);
              shot.totalHit[i]+=dmg;
            }
            const d=Math.max(1,Math.hypot(dx,dy)); opp.vx += (dx/d)*0.45; opp.vy += (dy/d)*0.25-0.15;
            pellets.splice(k,1);
            continue;
          }
        }
        if (ix>=0 && ix<W && iy>=0 && iy<H && terrainMask[iy*W+ix]===SOLID){
          carveCrater(p.x,p.y,10);
          applySplashDamageCapped(p.x,p.y,12, 50);
          for(let i=0;i<6;i++){
            const a=Math.random()*Math.PI*2, sp=1+Math.random()*2.5;
            particles.push({x:p.x,y:p.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-1.2,life:28,smoke:false});
          }
          pellets.splice(k,1);
        }
      }
      if (pellets.length===0){ noiseBoom(0.2,0.2); endShot({terrain:true}); }
    }

    if (shot.kind==='drill'){
      const s=shot;
      s.vx += wind*0.15; s.vy += G*0.1;
      s.x += s.vx; s.y += s.vy;
      carveCrater(s.x, s.y, s.r);
      const me = players[turn];
      const dx = s.x - me.x, dy = s.y - me.y;
      if (Math.hypot(dx,dy) < 26){
        me.vx += dx*0.02; me.vy += dy*0.02 - 0.06;
      }
      s.life--;
      if (s.x<0 || s.x>=W || s.y<0 || s.y>=H || s.life<=0){
        poof(); endShot({terrain:true}); return;
      }
      particles.push({x:s.x,y:s.y,vx:(Math.random()-0.5)*1.2,vy:(Math.random()-1.2),life:18,smoke:false});
    }
  }

  function endShot(){
    shot=null;
    if (players[0].hp>0 && players[1].hp>0){
      // do nothing; retreat/turn handled by timer
    }
  }

  // ======= Terrain carving =======
  function carveCrater(cx,cy,r=EXPLOSION_R){
    const minx=Math.max(0,Math.floor(cx-r)), maxx=Math.min(W-1,Math.ceil(cx+r));
    const miny=Math.max(0,Math.floor(cy-r)), maxy=Math.min(H-1,Math.ceil(cy+r));
    const img = terrCtx.getImageData(minx,miny,maxx-minx+1,maxy-miny+1);
    const d = img.data, rr=r*r;
    for(let y=miny;y<=maxy;y++){
      for(let x=minx;x<=maxx;x++){
        const dx=x-cx, dy=y-cy;
        if (dx*dx+dy*dy<=rr){
          const idx=y*W+x; terrainMask[idx]=SKY;
          const p=((y-miny)*(maxx-minx+1)+(x-minx))*4; d[p+3]=0;
        }
      }
    }
    terrCtx.putImageData(img,minx,miny);
    for(let x=minx;x<=maxx;x++){
      let y; for(y=0;y<H;y++){ if (terrainMask[y*W+x]===SOLID) break; }
      heightmap[x]=(y===H)?H:y;
    }
    const g=decalCtx.createRadialGradient(cx,cy,2,cx,cy,r);
    g.addColorStop(0,'rgba(0,0,0,0.28)'); g.addColorStop(1,'rgba(0,0,0,0)');
    decalCtx.fillStyle=g; decalCtx.beginPath(); decalCtx.arc(cx,cy,r,0,Math.PI*2); decalCtx.fill();
  }

  // ======= Players physics & movement =======
  function groundYAt(x){ x=Math.max(0,Math.min(W-1,x|0)); return heightmap[x]; }
  function stepPlayers(){
    for (let i=0;i<2;i++){
      const p=players[i];

      // Apply joystick to current player only during move/retreat (and not while teleport placing)
      if (i===turn && !placingTeleport && (phase==='move' || phase==='retreat') && !shot){
        const speed = 0.25; // slower walking
        p.vx += speed * (joyDX||0);
        // clamp
        p.vx = Math.max(-1.2, Math.min(1.2, p.vx));
        // jump with coyote time
        p.coyote = (p.coyote||0);
        const onGroundNow = terrainMask[Math.min(H-1,(p.y+PLAYER_R+1|0))*W + (p.x|0)]===SOLID;
        if (onGroundNow) p.coyote = 6; else p.coyote = Math.max(0, p.coyote-1);
        if (jumpQueued && p.coyote>0){ p.vy = -3.6; tone(560,0.05,'sine',0.1); p.coyote=0; }
      }

      const under = terrainMask[Math.min(H-1,(p.y+PLAYER_R+1|0))*W + (p.x|0)];
      const onSolid = (under===SOLID);

      if (!onSolid){
        p.vy += G; p.y += p.vy; p.x += p.vx;
        const gy = groundYAt(p.x);
        if (p.y+PLAYER_R > gy){
          const over = p.y+PLAYER_R - gy;
          const prevVy = p.vy;
          p.y = gy-PLAYER_R; p.vy=0; p.vx*=0.7;
          if (fallChk.checked){
            const drop = Math.abs(prevVy*8 + over);
            if (drop>FALL_NO_DMG){
     
