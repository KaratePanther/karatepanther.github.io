<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>2048 — Anton’s minimal version</title>
<meta name="description" content="Tiny single-file 2048 game with keyboard and swipe." />
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LN5WKNMNR1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-LN5WKNMNR1');
</script>
<style>
  :root{
    --bg:#0b1020; --ink:#e8ecff; --muted:#aab3d9; --card:#121932; --line:#233055; --accent:#6ea8fe;
    --radius:16px; --pad:14px; --size:78vmin; --max:520px; --gap:10px;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b1020,#0c1430);color:var(--ink);
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
  .wrap{max-width: min(var(--max), 92vw); margin:22px auto; padding:0 10px}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:14px}
  h1{margin:0;font-size:22px;letter-spacing:.3px}
  .scores{display:flex;gap:10px}
  .badge{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:8px 10px;text-align:center;min-width:84px}
  .badge .label{font-size:12px;color:var(--muted)}
  .badge .val{font-weight:700;font-size:18px}
  .controls{display:flex;gap:10px;margin:10px 0 16px}
  .btn{background:var(--accent);color:#02102a;border:0;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .hint{color:var(--muted);font-size:13px}

  .board{position:relative; width:min(var(--size), 92vw); height:min(var(--size), 92vw);
    max-width:var(--max); max-height:var(--max); background:#0f1a3b;border-radius:18px;
    padding:var(--gap); margin:0 auto; box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .grid{position:absolute; inset:var(--gap); display:grid; grid-template-columns:repeat(4,1fr); grid-template-rows:repeat(4,1fr); gap:var(--gap)}
  .cell{background:#111f47;border-radius:12px;border:1px solid #1a2a57}

  .tiles{position:absolute; inset:var(--gap)}
  .tile{
    position:absolute; display:flex; align-items:center; justify-content:center;
    font-weight:800; border-radius:12px; user-select:none; -webkit-user-select:none;
    transition: transform .12s ease-out; will-change:transform; border:1px solid rgba(0,0,0,.1)
  }
  .tile.new{animation:pop .12s ease-out}
  @keyframes pop { from{transform:scale(.7)} to{transform:scale(1)} }

  /* Colors per value */
  .v2 {background:#1d2a55; color:#dfe7ff}
  .v4 {background:#203064; color:#eaf0ff}
  .v8 {background:#284088; color:#fff}
  .v16{background:#3350a8; color:#fff}
  .v32{background:#3a63c1; color:#fff}
  .v64{background:#4375da; color:#fff}
  .v128{background:#5990ff; color:#001224}
  .v256{background:#75a4ff; color:#001224}
  .v512{background:#90b8ff; color:#001224}
  .v1024{background:#b1cdff; color:#001224}
  .v2048{background:#ffd166; color:#1a1300}

  .overlay{
    position:absolute; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(9,12,26,.72); backdrop-filter: blur(2px); border-radius:18px
  }
  .overlay.show{display:flex}
  .panel{background:var(--card); border:1px solid var(--line); padding:16px 18px; border-radius:14px; text-align:center}
  .panel h2{margin:0 0 6px}
  .panel p{margin:0 0 12px; color:var(--muted)}
  .panel .btn{background:#ffd166}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>2048</h1>
      <div class="scores">
        <div class="badge"><div class="label">Score</div><div id="score" class="val">0</div></div>
        <div class="badge"><div class="label">Best</div><div id="best" class="val">0</div></div>
      </div>
    </header>

    <div class="controls">
      <button id="new" class="btn" title="Start a new game">New Game</button>
      <span class="hint">Use ← ↑ → ↓ or swipe. Reach <strong>2048</strong>!</span>
    </div>

    <div id="board" class="board" aria-label="2048 game board" role="application">
      <div class="grid" aria-hidden="true">
        <!-- background cells -->
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      </div>
      <div class="tiles" id="tiles"></div>
      <div id="overlay" class="overlay" aria-hidden="true">
        <div class="panel">
          <h2 id="over-title">Game Over</h2>
          <p id="over-text">No more moves.</p>
          <button id="again" class="btn">Play Again</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const SIZE = 4;
  const tilesEl = document.getElementById('tiles');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const overlay = document.getElementById('overlay');
  const newBtn  = document.getElementById('new');
  const againBtn= document.getElementById('again');
  const overTitle = document.getElementById('over-title');
  const overText  = document.getElementById('over-text');

  const bestKey = '2048_best_v1';

  let grid, score, moved, mergedAny, animating = false;

  function init() {
    grid = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
    score = 0;
    setScore(0);
    const best = +localStorage.getItem(bestKey) || 0;
    bestEl.textContent = best;
    overlay.classList.remove('show');
    clearTiles();
    addRandomTile(); addRandomTile();
    draw();
  }

  function setScore(n){
    score = n;
    scoreEl.textContent = score;
    const best = +localStorage.getItem(bestKey) || 0;
    if (score > best){
      localStorage.setItem(bestKey, score);
      bestEl.textContent = score;
    }
  }

  function clearTiles(){ tilesEl.innerHTML = ''; }

  function eachCell(cb){
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) cb(r,c);
  }

  function emptyCells(){
    const out=[];
    eachCell((r,c)=>{ if(!grid[r][c]) out.push([r,c]) });
    return out;
  }

  function addRandomTile(){
    const empties = emptyCells();
    if (!empties.length) return false;
    const [r,c] = empties[Math.floor(Math.random()*empties.length)];
    grid[r][c] = Math.random() < 0.9 ? 2 : 4;
    return true;
  }

  function draw(){
    tilesEl.innerHTML = '';
    const boardRect = tilesEl.getBoundingClientRect();
    const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 10;
    const cellW = (boardRect.width - (gap*3)) / 4; // 4 cols with 3 gaps
    // Precompute positions
    const pos = (i) => i * (cellW + gap);
    eachCell((r,c) => {
      const v = grid[r][c];
      if (!v) return;
      const el = document.createElement('div');
      el.className = `tile v${v} new`;
      el.textContent = v;
      el.style.width = el.style.height = cellW + 'px';
      el.style.transform = `translate(${pos(c)}px, ${pos(r)}px)`;
      tilesEl.appendChild(el);
    });
  }

  function slide(row){
    // compress non-zero
    const arr = row.filter(v=>v);
    mergedAny = false;
    for (let i=0;i<arr.length-1;i++){
      if (arr[i] !== 0 && arr[i] === arr[i+1]){
        arr[i] *= 2;
        setScore(score + arr[i]);
        arr[i+1] = 0;
        mergedAny = true;
        i++;
      }
    }
    return arr.filter(v=>v).concat(Array(SIZE).fill(0)).slice(0,SIZE);
  }

  function moveLeft(){
    moved = false;
    for (let r=0;r<SIZE;r++){
      const current = grid[r].slice();
      const next = slide(current);
      if (!arraysEqual(current, next)){ moved = true; grid[r] = next; }
    }
    return moved;
  }
  function moveRight(){
    moved = false;
    for (let r=0;r<SIZE;r++){
      const current = grid[r].slice().reverse();
      const next = slide(current).reverse();
      if (!arraysEqual(grid[r], next)){ moved = true; grid[r] = next; }
    }
    return moved;
  }
  function moveUp(){
    moved = false;
    for (let c=0;c<SIZE;c++){
      const col = [];
      for (let r=0;r<SIZE;r++) col.push(grid[r][c]);
      const next = slide(col);
      for (let r=0;r<SIZE;r++){
        if (grid[r][c] !== next[r]) { moved = true; grid[r][c] = next[r]; }
      }
    }
    return moved;
  }
  function moveDown(){
    moved = false;
    for (let c=0;c<SIZE;c++){
      const col = [];
      for (let r=0;r<SIZE;r++) col.push(grid[r][c]);
      const next = slide(col.reverse()).reverse();
      for (let r=0;r<SIZE;r++){
        if (grid[r][c] !== next[r]) { moved = true; grid[r][c] = next[r]; }
      }
    }
    return moved;
  }

  function arraysEqual(a,b){
    if (a.length !== b.length) return false;
    for (let i=0;i<a.length;i++) if (a[i]!==b[i]) return false;
    return true;
  }

  function anyMovesLeft(){
    if (emptyCells().length) return true;
    // check merges
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const v = grid[r][c];
        if ((c+1<SIZE && grid[r][c+1]===v) || (r+1<SIZE && grid[r+1][c]===v)) return true;
      }
    }
    return false;
  }

  function afterMove(){
    if (moved){
      addRandomTile();
      draw();
      if (!anyMovesLeft()){
        overTitle.textContent = 'Game Over';
        overText.textContent  = 'No more moves. Try again!';
        overlay.classList.add('show');
        overlay.setAttribute('aria-hidden','false');
      } else {
        // Win check (optional visual)
        if (grid.flat().includes(2048)){
          overTitle.textContent = 'You win!';
          overText.textContent  = 'Keep playing to get an even higher score.';
          overlay.classList.add('show');
          overlay.setAttribute('aria-hidden','false');
        }
      }
    }
    animating = false;
  }

  // Input — keyboard
  window.addEventListener('keydown', (e) => {
    const key = e.key;
    if (!['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(key)) return;
    e.preventDefault(); // prevent page scroll
    if (animating) return;
    animating = true;
    let did;
    if (key==='ArrowLeft') did = moveLeft();
    else if (key==='ArrowRight') did = moveRight();
    else if (key==='ArrowUp') did = moveUp();
    else if (key==='ArrowDown') did = moveDown();
    requestAnimationFrame(afterMove);
  }, {passive:false});

  // Input — swipe (anywhere)
  let startX=0,startY=0, tracking=false;
  const minDist = 24; // px threshold
  function onStart(e){
    const t = e.touches ? e.touches[0] : e;
    startX = t.clientX; startY = t.clientY; tracking=true;
  }
  function onMove(e){
    if (!tracking) return;
    // Prevent page from moving while swiping
    e.preventDefault();
  }
  function onEnd(e){
    if (!tracking) return;
    tracking=false;
    const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : e;
    const dx = t.clientX - startX;
    const dy = t.clientY - startY;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    if (Math.max(adx, ady) < minDist) return;
    if (animating) return;
    animating = true;
    if (adx > ady){
      if (dx>0) moveRight(); else moveLeft();
    }else{
      if (dy>0) moveDown(); else moveUp();
    }
    requestAnimationFrame(afterMove);
  }
  // Attach to window so swipes work anywhere and page doesn't wiggle
  window.addEventListener('touchstart', onStart, {passive:false});
  window.addEventListener('touchmove', onMove, {passive:false});
  window.addEventListener('touchend', onEnd, {passive:false});
  window.addEventListener('mousedown', onStart);
  window.addEventListener('mouseup', onEnd);

  // Buttons
  newBtn.addEventListener('click', init);
  againBtn.addEventListener('click', init);

  // Kick off
  init();

  // Accessibility: focus ring suppression on click
  document.body.addEventListener('mousedown', () => { document.body.classList.add('using-mouse'); });
})();
</script>
</body>
</html>
