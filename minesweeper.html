<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Minesweeper</title>
<meta name="description" content="Modern, mobile-friendly Minesweeper in a single file." />
<style>
  :root{
    --bg:#0b1020; --card:#121932; --ink:#e8ecff; --muted:#aab3d9;
    --line:#233055; --accent:#6ea8fe; --accent-2:#90c2ff; --ok:#22c55e; --warn:#f59e0b; --danger:#ef4444;
    --radius:16px; --pad:14px; --maxw:860px;

    /* Board sizing vars */
    --tile:44px;         /* used in Fit-to-Width mode; computed dynamically */
    --tile-base:40px;    /* native tile in Zoomable mode */
    --gap:6px;           /* grid gap (preset-dependent) */
    --tile-font:18px;    /* number font size (preset-dependent) */

    /* Mobile safe areas */
    --safe-l: env(safe-area-inset-left, 0px);
    --safe-r: env(safe-area-inset-right, 0px);
    --safe-b: env(safe-area-inset-bottom, 0px);
  }

  *{box-sizing:border-box}
  html,body{margin:0;background:linear-gradient(180deg,#0b1020,#0e1430);color:var(--ink);
    font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  a{color:inherit}
  .wrap{max-width:var(--maxw);margin:0 auto;padding:18px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:var(--radius);padding:18px;box-shadow:0 6px 24px rgba(0,0,0,.25)}

  h1{margin:0 0 6px;font-size:24px}
  .muted{color:var(--muted)}

  .topbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:space-between;margin-bottom:12px}
  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn,.select{
    appearance:none;border:1px solid var(--line);background:#0e1530;color:var(--ink);
    padding:10px 12px;border-radius:12px;cursor:pointer
  }
  .btn:hover{border-color:#2f3b6a}
  .btn.primary{background:var(--accent);color:#08112a;border-color:transparent}
  .btn.toggle{display:flex;align-items:center;gap:8px}
  .btn[aria-pressed="true"]{outline:2px solid var(--accent-2)}
  .stat{display:flex;align-items:center;gap:6px;background:#0e1530;border:1px solid var(--line);
    padding:8px 10px;border-radius:10px;min-width:88px;justify-content:center}

  /* Board viewport + inner board (for pan/zoom) */
  .board-viewport{
    position:relative;
    border-radius:14px;border:1px solid var(--line);background:#0d142e;padding:8px;
    overflow:hidden; /* viewport clips inner board during pan/zoom */
    touch-action:none; /* we‚Äôll manage gestures */
  }
  .board-panzoom{
    transform-origin: 0 0;
    will-change: transform;
  }

  /* The grid itself (same element used in both modes) */
  .board{
    display:grid;gap:var(--gap);
  }

  .tile{
    width:var(--tile);height:var(--tile);display:grid;place-items:center;
    background:linear-gradient(180deg,#0f1a3a,#0b1430);
    border:1px solid #17244a;border-radius:10px;user-select:none; -webkit-user-select:none;
    font-weight:700; font-size:var(--tile-font); cursor:pointer; position:relative;
  }
  .tile.revealed{
    background:linear-gradient(180deg,#111b3c,#0e1835);
    border-color:#21325f; box-shadow:inset 0 2px 6px rgba(0,0,0,.35); cursor:default;
  }
  .tile.mine.revealed{background:radial-gradient(circle at 50% 45%, #2b0f17, #12060b 70%);}
  .tile.mine .dot{width:18px;height:18px;border-radius:50%;background:var(--danger);box-shadow:0 0 10px rgba(239,68,68,.7)}
  .tile.flag::after{
    content:"‚öë";position:absolute;inset:0;display:grid;place-items:center;font-size:20px;color:#f43f5e;text-shadow:0 0 6px rgba(244,63,94,.6)
  }
  .tile.question::after{
    content:"?";position:absolute;inset:0;display:grid;place-items:center;font-size:18px;color:#fbbf24
  }
  .tile.dead{animation:boom .45s ease-out}
  @keyframes boom {0%{transform:scale(1)} 35%{transform:scale(1.12)} 100%{transform:scale(1)}}

  /* number colors */
  .n1{color:#93c5fd}.n2{color:#86efac}.n3{color:#fca5a5}.n4{color:#c4b5fd}
  .n5{color:#fcd34d}.n6{color:#67e8f9}.n7{color:#fecaca}.n8{color:#cbd5e1}

  .footer{margin-top:10px;display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap}
  .legend{display:flex;gap:14px;align-items:center;color:var(--muted);font-size:14px}
  .legend .pill{display:inline-flex;align-items:center;gap:6px;background:#0e1530;border:1px solid var(--line);padding:6px 10px;border-radius:999px}

  /* Floating action buttons (mobile) */
  .fabs{position:relative}
  .fab{
    position:fixed; bottom:calc(14px + var(--safe-b)); width:48px; height:48px; border-radius:50%;
    display:grid; place-items:center; border:1px solid var(--line); background:#0e1530;
    box-shadow:0 6px 18px rgba(0,0,0,.35); z-index:10;
  }
  .fab.left{ left:calc(14px + var(--safe-l)); }
  .fab.right{ right:calc(14px + var(--safe-r)); }
  .fab.primary{ background:var(--accent); color:#08112a; border-color:transparent }

  /* Compact topbar on small screens */
  @media (max-width: 560px){
    .topbar h1{font-size:20px}
    .muted.short-help{display:none}
  }

  /* High-contrast tweak when tiles get smaller (we toggle a class in JS) */
  .tiny-tiles .tile{ border-color:#2a3b74 }
  .tiny-tiles .board{ gap:3px }

</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <div>
          <h1>Minesweeper</h1>
          <div class="muted short-help">Reveal all safe tiles. Flag the mines. First click is always safe.</div>
        </div>
        <div class="controls">
          <select id="difficulty" class="select" title="Difficulty">
            <option value="9x9x10">Beginner 9√ó9 ¬∑ 10üí£</option>
            <option value="16x16x40">Intermediate 16√ó16 ¬∑ 40üí£</option>
            <option value="30x16x99">Expert 30√ó16 ¬∑ 99üí£</option>
            <option value="custom">Custom‚Ä¶</option>
          </select>
          <select id="density" class="select" title="Tile density">
            <option value="comfort">Comfort</option>
            <option value="compact" selected>Compact</option>
            <option value="ultra">Ultra</option>
          </select>
          <button id="flagMode" class="btn toggle" aria-pressed="false" title="Toggle Flag Mode (mobile)">
            <span>üö© Flag Mode</span>
          </button>
          <button id="reset" class="btn primary" title="Restart (R)">‚Üª Restart</button>
        </div>
      </div>

      <div class="controls" id="customRow" style="display:none;margin-bottom:8px">
        <label class="muted">W <input id="w" type="number" min="5" max="50" value="12" style="width:64px;margin-left:6px" /></label>
        <label class="muted">H <input id="h" type="number" min="5" max="30" value="12" style="width:64px;margin-left:6px" /></label>
        <label class="muted">üí£ <input id="m" type="number" min="1" max="400" value="24" style="width:80px;margin-left:6px" /></label>
        <button id="applyCustom" class="btn">Apply</button>
      </div>

      <div class="controls" style="margin-bottom:10px">
        <div class="stat" id="mineCount" title="Mines remaining">üí£ 000</div>
        <div class="stat" id="timer" title="Timer">‚è± 000</div>
        <div class="stat" id="status" aria-live="polite">üôÇ Ready</div>
      </div>

      <!-- Viewport (clips & hosts zoom/pan) -->
      <div class="board-viewport" id="viewport">
        <div class="board-panzoom" id="panzoom">
          <div id="board" class="board" aria-label="Minesweeper board" role="grid"></div>
        </div>
      </div>

      <div class="footer">
        <div class="legend">
          <span class="pill">üñ± Left: Reveal</span>
          <span class="pill">Right: Flag</span>
          <span class="pill">üì± Long-press: Flag</span>
          <span class="pill">Double-tap to zoom</span>
        </div>
        <div class="muted">Keys: R=restart, F=flag mode, Arrow+Enter works too.</div>
      </div>

      <!-- Floating buttons (mobile-friendly) -->
      <div class="fabs">
        <button id="fabReset" class="fab left" title="Restart">‚Üª</button>
        <button id="fabFlag" class="fab right" title="Flag Mode">üö©</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ------- Utilities -------
  const $ = sel => document.querySelector(sel);
  const boardEl = $("#board");
  const viewportEl = $("#viewport");
  const panzoomEl = $("#panzoom");
  const timerEl = $("#timer");
  const minesEl = $("#mineCount");
  const statusEl = $("#status");
  const resetBtn = $("#reset");
  const fabReset = $("#fabReset");
  const diffSel = $("#difficulty");
  const densitySel = $("#density");
  const flagBtn = $("#flagMode");
  const fabFlag = $("#fabFlag");
  const customRow = $("#customRow");
  const wInput = $("#w"), hInput = $("#h"), mInput = $("#m");
  const applyCustom = $("#applyCustom");

  // Persist some preferences
  const store = {
    get(k, d){ try{ return JSON.parse(localStorage.getItem(k) ?? "null") ?? d; }catch{ return d; } },
    set(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch{} }
  };

  let W=9,H=9,MINES=10;
  let grid=[], revealed=0, flags=0, started=false, dead=false, won=false;
  let timer=0, tInt=null;
  let firstClickCell = null;
  let longPressTimer = null;

  // Mode & view state
  const MODES = { FIT: "fit", ZOOM: "zoom" };
  let mode = MODES.FIT;
  let scale = 1, minScale = 1, maxScale = 2;
  let tx = 0, ty = 0;   // translation for pan
  let lastTapTime = 0;

  // Density presets
  const applyDensity = (preset) => {
    if(preset === "comfort"){
      document.documentElement.style.setProperty("--gap", "6px");
      document.documentElement.style.setProperty("--tile-font", "18px");
      document.documentElement.style.setProperty("--tile", "44px");
    } else if(preset === "compact"){
      document.documentElement.style.setProperty("--gap", "4px");
      document.documentElement.style.setProperty("--tile-font", "16px");
      document.documentElement.style.setProperty("--tile", "40px");
    } else { // ultra
      document.documentElement.style.setProperty("--gap", "2px");
      document.documentElement.style.setProperty("--tile-font", "14px");
      document.documentElement.style.setProperty("--tile", "36px");
    }
    store.set("density", preset);
    layout(); // re-evaluate mode/scale on density change
  };

  // Neighbor helper
  const neighbors = (x,y) => {
    const res=[];
    for(let dy=-1;dy<=1;dy++){
      for(let dx=-1;dx<=1;dx++){
        if(dx===0 && dy===0) continue;
        const nx=x+dx, ny=y+dy;
        if(nx>=0 && nx<W && ny>=0 && ny<H) res.push([nx,ny]);
      }
    }
    return res;
  };

  const setStatus = (txt, emoji="üôÇ") => {
    statusEl.textContent = `${emoji} ${txt}`;
  };

  const stopTimer = () => { if(tInt){ clearInterval(tInt); tInt=null; } };
  const startTimer = () => {
    stopTimer();
    tInt = setInterval(()=>{ timer++; updateTimer(); },1000);
  };
  const pad3 = n => String(n).padStart(3,"0");
  const updateTimer = () => timerEl.textContent = `‚è± ${pad3(timer)}`;
  const updateMinesLeft = () => minesEl.textContent = `üí£ ${pad3(MINES - flags)}`;
  const classForNum = n => n ? `n${Math.max(1,Math.min(8,n))}` : "";

  // ------- Board Setup -------
  function newGame(w=W,h=H,m=MINES){
    W=w; H=h; MINES=Math.min(m, W*H-1);
    grid = new Array(H).fill(0).map(()=> new Array(W).fill(0).map(()=>({
      mine:false, count:0, revealed:false, flagged:false, question:false, el:null
    })));
    revealed=0; flags=0; started=false; dead=false; won=false; timer=0;
    firstClickCell = null;
    updateTimer(); updateMinesLeft(); setStatus("Ready","üôÇ");
    stopTimer();

    // Build DOM grid
    boardEl.style.gridTemplateColumns = `repeat(${W}, ${mode===MODES.ZOOM ? 'var(--tile-base)' : 'var(--tile)'})`;
    boardEl.setAttribute("aria-rowcount", H);
    boardEl.innerHTML = "";
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const d = grid[y][x];
        const tile = document.createElement("button");
        tile.className = "tile";
        tile.style.width  = mode===MODES.ZOOM ? "var(--tile-base)" : "var(--tile)";
        tile.style.height = mode===MODES.ZOOM ? "var(--tile-base)" : "var(--tile)";
        tile.setAttribute("role","gridcell");
        tile.setAttribute("data-x",x);
        tile.setAttribute("data-y",y);
        tile.setAttribute("aria-label","Hidden");
        tile.oncontextmenu = e => { e.preventDefault(); toggleFlag(x,y); };
        tile.addEventListener("mousedown", e => { if(e.button===2) e.preventDefault(); });
        tile.addEventListener("click", e => {
          if (flagBtn.getAttribute("aria-pressed")==="true") { toggleFlag(x,y); return; }
          reveal(x,y);
        });
        tile.addEventListener("dblclick", e => { chord(x,y); });

        // Mobile long-press to flag
        tile.addEventListener("touchstart", e => {
          if(e.touches.length>1) return; // ignore multi-touch
          longPressTimer = setTimeout(()=>{ toggleFlag(x,y); longPressTimer=null; }, 420);
        }, {passive:true});
        tile.addEventListener("touchend", e => {
          if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null;
            if (flagBtn.getAttribute("aria-pressed")==="true") return;
            reveal(x,y);
          }
        }, {passive:true});
        tile.addEventListener("touchmove", e => {
          if(longPressTimer) { clearTimeout(longPressTimer); longPressTimer=null; }
        }, {passive:true});

        d.el = tile;
        boardEl.appendChild(tile);
      }
    }

    // After building, recalc layout/scale
    layout(true);
  }

  // place mines AFTER first click to guarantee safety on first reveal
  function placeMines(safeX, safeY){
    const forbid = new Set([`${safeX},${safeY}`]);
    neighbors(safeX,safeY).forEach(([nx,ny]) => forbid.add(`${nx},${ny}`));

    let placed=0;
    while(placed<MINES){
      const x = Math.floor(Math.random()*W);
      const y = Math.floor(Math.random()*H);
      const key = `${x},${y}`;
      if(forbid.has(key)) continue;
      const d = grid[y][x];
      if(!d.mine){
        d.mine=true;
        placed++;
      }
    }
    // compute counts
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        if(grid[y][x].mine) continue;
        let c=0;
        neighbors(x,y).forEach(([nx,ny]) => { if(grid[ny][nx].mine) c++; });
        grid[y][x].count=c;
      }
    }
  }

  // ------- Interactions -------
  function toggleFlag(x,y){
    if(dead||won) return;
    const d = grid[y][x];
    if(d.revealed) return;
    if(!started){ started=true; startTimer(); }
    if(!d.flagged && flags>=MINES) return; // optional limit
    d.flagged = !d.flagged;
    d.question = false;
    flags += d.flagged ? 1 : -1;
    renderTile(x,y);
    updateMinesLeft();
    checkWin();
  }

  function reveal(x,y){
    if(dead||won) return;
    const d = grid[y][x];
    if(d.revealed||d.flagged) return;

    if(!started){
      started=true; startTimer();
      firstClickCell = [x,y];
      placeMines(x,y);
    }

    if(d.mine){
      boom(x,y);
      return;
    }

    floodReveal(x,y);
    checkWin();
  }

  function floodReveal(x,y){
    const q = [[x,y]];
    while(q.length){
      const [cx,cy] = q.shift();
      const c = grid[cy][cx];
      if(c.revealed || c.flagged) continue;
      c.revealed = true;
      c.el.classList.add("revealed");
      c.el.setAttribute("aria-label", c.mine ? "Mine" : `Revealed ${c.count}`);
      revealed++;
      renderTile(cx,cy);
      if(c.count===0){
        neighbors(cx,cy).forEach(([nx,ny])=>{
          const n=grid[ny][nx];
          if(!n.revealed && !n.flagged && !n.mine) q.push([nx,ny]);
        });
      }
    }
    if(mode===MODES.ZOOM){
      // focus-follow: center revealed cluster roughly
      centerOn(x,y, 0.25);
    }
  }

  // Chord
  function chord(x,y){
    if(dead||won) return;
    const d = grid[y][x];
    if(!d.revealed || d.count===0) return;
    const adj = neighbors(x,y);
    const flagCount = adj.reduce((acc,[nx,ny])=>acc + (grid[ny][nx].flagged?1:0),0);
    if(flagCount === d.count){
      for(const [nx,ny] of adj){
        const n = grid[ny][nx];
        if(!n.flagged && !n.revealed){
          if(n.mine){ boom(nx,ny); return; }
          floodReveal(nx,ny);
        }
      }
      checkWin();
    }
  }

  function boom(x,y){
    dead=true; stopTimer();
    setStatus("Boom! You hit a mine.","üí•");
    for(let yy=0; yy<H; yy++){
      for(let xx=0; xx<W; xx++){
        const d=grid[yy][xx];
        if(d.mine){
          d.revealed=true;
          renderTile(xx,yy);
        }
      }
    }
    grid[y][x].el.classList.add("dead");
  }

  function checkWin(){
    if(dead || won) return;
    const safe = W*H - MINES;
    if(revealed >= safe){
      won=true; stopTimer();
      setStatus("You win!","üèÜ");
      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          const d=grid[y][x];
          if(!d.revealed && !d.flagged){ d.flagged=true; flags++; renderTile(x,y); }
        }
      }
      updateMinesLeft();
    }
  }

  // ------- Rendering -------
  function renderTile(x,y){
    const d = grid[y][x], el = d.el;
    el.classList.remove("flag","question","mine","n1","n2","n3","n4","n5","n6","n7","n8");
    el.textContent = "";
    if(d.revealed){
      el.classList.add("revealed");
      if(d.mine){
        el.classList.add("mine");
        if(!el.querySelector(".dot")){
          const dot = document.createElement("div");
          dot.className="dot";
          el.appendChild(dot);
        }
      }else if(d.count>0){
        el.classList.add(classForNum(d.count));
        el.textContent = d.count;
      }
    }else{
      if(d.flagged) el.classList.add("flag");
      else if(d.question) el.classList.add("question");
    }
  }

  // ------- Layout / Mode selection -------
  const MIN_TAP = 32; // px

  function layout(resetPan=false){
    // Decide mode based on column count and resulting tile size
    const cols = W;
    // usable width = viewport width - paddings (viewport has 8px pad inside card already)
    const vpRect = viewportEl.getBoundingClientRect();
    const gap = parseFloat(getComputedStyle(boardEl).gap) || 4;

    // Try Fit-to-Width: compute tile size that fills width
    const fitTile = Math.floor((vpRect.width - (cols-1)*gap) / cols);

    const shouldFit = (cols <= 12) && (fitTile >= MIN_TAP);
    const newMode = shouldFit ? MODES.FIT : MODES.ZOOM;

    if(newMode !== mode){
      mode = newMode;
      // Rebuild tile sizing basis
      boardEl.style.gridTemplateColumns = `repeat(${W}, ${mode===MODES.ZOOM ? 'var(--tile-base)' : 'var(--tile)'})`;
      // Also update each tile's inline size
      boardEl.querySelectorAll('.tile').forEach(t=>{
        t.style.width  = mode===MODES.ZOOM ? "var(--tile-base)" : "var(--tile)";
        t.style.height = mode===MODES.ZOOM ? "var(--tile-base)" : "var(--tile)";
      });
    }

    document.body.classList.toggle('tiny-tiles', !shouldFit);

    if(mode===MODES.FIT){
      // Fit: set --tile = fitTile px
      document.documentElement.style.setProperty('--tile', `${fitTile}px`);
      // Reset transform
      scale = 1; tx = 0; ty = 0;
      applyTransform();
    }else{
      // Zoomable: board built at native tile-base; compute scale to fit width
      const baseTile = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tile-base')) || 40;
      const contentW = (W * baseTile) + ((W-1) * gap);
      const fitScale = vpRect.width / contentW;
      // min scale is fit to width; max is 2x of that (cap overall to 2)
      minScale = Math.max(0.8, Math.min(1.0, fitScale)); // keep at least 0.8x for narrow devices
      scale = fitScale;
      maxScale = Math.max(scale * 1.4, scale + 0.4);
      if(resetPan){ tx = 0; ty = 0; }
      applyTransform();
    }
  }

  function applyTransform(){
    panzoomEl.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
  }

  // Center-on helper for focus-follow
  function centerOn(x,y, lerp=0){
    const gap = parseFloat(getComputedStyle(boardEl).gap) || 4;
    const baseTile = mode===MODES.ZOOM
      ? (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tile-base')) || 40)
      : (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 40);
    const tileSize = baseTile;
    // target tile's top-left in content coords
    const cx = x * (tileSize + gap);
    const cy = y * (tileSize + gap);
    const vp = viewportEl.getBoundingClientRect();
    // we want tile roughly a bit inside viewport (center-ish)
    const targetTx = Math.min(0, Math.max(vp.width - contentWidth(), -cx + vp.width*0.5 - tileSize*0.5));
    const targetTy = Math.min(0, Math.max(vp.height - contentHeight(), -cy + vp.height*0.4 - tileSize*0.5));
    if(lerp>0){
      tx = tx + (targetTx - tx)*lerp;
      ty = ty + (targetTy - ty)*lerp;
    }else{
      tx = targetTx; ty = targetTy;
    }
    applyTransform();
  }

  function contentWidth(){
    const gap = parseFloat(getComputedStyle(boardEl).gap) || 4;
    const baseTile = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tile-base')) || 40);
    return (W * baseTile + (W-1)*gap) * scale;
  }
  function contentHeight(){
    const gap = parseFloat(getComputedStyle(boardEl).gap) || 4;
    const baseTile = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tile-base')) || 40);
    return (H * baseTile + (H-1)*gap) * scale;
  }

  // ------- Pan / Zoom gestures (Zoomable mode) -------
  let dragging = false;
  let lastX = 0, lastY = 0;
  let pinch = null;

  function clampPan(){
    const vp = viewportEl.getBoundingClientRect();
    const cw = contentWidth(), ch = contentHeight();
    // Clamp so content edges don't leave too far (allow small overpan)
    const over = 32;
    const minX = Math.min(0 + over, vp.width - cw - over);
    const maxX = Math.max(0 - over, vp.width - cw + over);
    const minY = Math.min(0 + over, vp.height - ch - over);
    const maxY = Math.max(0 - over, vp.height - ch + over);
    tx = Math.max(minX, Math.min(maxX, tx));
    ty = Math.max(minY, Math.min(maxY, ty));
  }

  function onPointerDown(e){
    if(mode!==MODES.ZOOM) return;
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
    panzoomEl.setPointerCapture(e.pointerId);
  }
  function onPointerMove(e){
    if(mode!==MODES.ZOOM) return;
    if(dragging && !pinch){
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      tx += dx; ty += dy;
      clampPan();
      applyTransform();
    }
  }
  function onPointerUp(e){
    if(mode!==MODES.ZOOM) return;
    dragging = false;
    panzoomEl.releasePointerCapture(e.pointerId);
    // snap-to-grid lightly (optional)
    tx = Math.round(tx); ty = Math.round(ty);
    applyTransform();
  }

  // Double-tap to toggle zoom
  function onViewportTap(e){
    const now = Date.now();
    if(now - lastTapTime < 300){ // double tap
      const targetScale = (scale <= minScale*1.02) ? Math.min(maxScale, minScale*1.4) : minScale;
      // Zoom around the tap point: adjust translation so tapped point stays under finger
      const rect = viewportEl.getBoundingClientRect();
      const px = (e.clientX - rect.left - tx) / scale;
      const py = (e.clientY - rect.top - ty) / scale;
      scale = targetScale;
      tx = e.clientX - rect.left - px * scale;
      ty = e.clientY - rect.top - py * scale;
      clampPan();
      applyTransform();
    }
    lastTapTime = now;
  }

  // Pinch (touch)
  function distance(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
  viewportEl.addEventListener("touchstart", (e)=>{
    if(mode!==MODES.ZOOM) return;
    if(e.touches.length===2){
      pinch = {
        d0: distance(e.touches[0], e.touches[1]),
        s0: scale,
        midX: (e.touches[0].clientX + e.touches[1].clientX)/2,
        midY: (e.touches[0].clientY + e.touches[1].clientY)/2
      };
    }
  }, {passive:true});
  viewportEl.addEventListener("touchmove", (e)=>{
    if(mode!==MODES.ZOOM) return;
    if(pinch && e.touches.length===2){
      const d = distance(e.touches[0], e.touches[1]);
      let ns = pinch.s0 * (d / pinch.d0);
      ns = Math.max(minScale, Math.min(maxScale, ns));
      // Zoom around pinch midpoint
      const rect = viewportEl.getBoundingClientRect();
      const px = (pinch.midX - rect.left - tx) / scale;
      const py = (pinch.midY - rect.top - ty) / scale;
      scale = ns;
      tx = pinch.midX - rect.left - px * scale;
      ty = pinch.midY - rect.top - py * scale;
      clampPan();
      applyTransform();
      e.preventDefault();
    }
  }, {passive:false});
  viewportEl.addEventListener("touchend", ()=>{
    if(mode!==MODES.ZOOM) return;
    if(!pinch || (pinch && pinch.d0 && pinch.s0)){
      pinch = null;
    }
  });

  // Mouse pan support
  panzoomEl.addEventListener("pointerdown", onPointerDown);
  panzoomEl.addEventListener("pointermove", onPointerMove);
  panzoomEl.addEventListener("pointerup", onPointerUp);
  panzoomEl.addEventListener("pointercancel", onPointerUp);
  viewportEl.addEventListener("pointerdown", (e)=>{
    // Also catch double-click by mouse
    if(e.pointerType === "mouse"){
      viewportEl.addEventListener("dblclick", ()=> onViewportTap(e), {once:true});
    }
  });
  viewportEl.addEventListener("click", onViewportTap);

  // ------- Controls & Init -------
  function softToggleFlagMode(){
    const on = flagBtn.getAttribute("aria-pressed")==="true";
    flagBtn.setAttribute("aria-pressed", String(!on));
  }

  resetBtn.addEventListener("click", ()=> newGame(W,H,MINES));
  fabReset.addEventListener("click", ()=> newGame(W,H,MINES));

  document.addEventListener("keydown", e=>{
    if(e.key.toLowerCase()==="r") newGame(W,H,MINES);
    if(e.key.toLowerCase()==="f") softToggleFlagMode();
  });
  flagBtn.addEventListener("click", softToggleFlagMode);
  fabFlag.addEventListener("click", softToggleFlagMode);

  diffSel.addEventListener("change", ()=>{
    if(diffSel.value==="custom"){
      customRow.style.display="";
    }else{
      customRow.style.display="none";
      const [w,h,m] = diffSel.value.split("x").map(Number);
      newGame(w,h,m);
      store.set("lastDiff", diffSel.value);
    }
  });
  applyCustom.addEventListener("click", ()=>{
    const w = Math.max(5, Math.min(50, +wInput.value||12));
    const h = Math.max(5, Math.min(30, +hInput.value||12));
    const maxM = Math.max(1, w*h - 1);
    const m = Math.max(1, Math.min(maxM, +mInput.value||Math.floor(w*h*0.18)));
    diffSel.value = "custom";
    newGame(w,h,m);
    store.set("lastDiff", `custom:${w}x${h}x${m}`);
  });

  densitySel.addEventListener("change", ()=>{
    applyDensity(densitySel.value);
  });

  // Prevent page scroll on touch within board area (keeps interactions crisp)
  // We now handle gestures on viewport, so prevent default there
  viewportEl.addEventListener("touchmove", e => { e.preventDefault(); }, {passive:false});

  // Re-layout on resize
  const ro = new ResizeObserver(()=> layout());
  ro.observe(viewportEl);

  // ------- Start -------
  // Restore prefs
  const savedDensity = store.get("density","compact");
  densitySel.value = savedDensity;
  applyDensity(savedDensity);

  const savedDiff = store.get("lastDiff","9x9x10");
  if(savedDiff.startsWith("custom:")){
    const v = savedDiff.replace("custom:","");
    const [w,h,m] = v.split("x").map(Number);
    diffSel.value = "custom";
    customRow.style.display="";
    wInput.value = w; hInput.value = h; mInput.value = m;
    newGame(w,h,m);
  }else{
    diffSel.value = savedDiff;
    const [w,h,m] = savedDiff.split("x").map(Number);
    newGame(w,h,m);
  }
})();
</script>
</body>
</html>