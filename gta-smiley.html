<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Smiley Duo Arcade — 4 Modes</title>
<meta name="description" content="Two-player virtual joysticks with Dodgeballs, Collect the Dots, Sumo Arena, and Maze. " />
<style>
  :root{
    --bg:#0b1020; --card:#121932; --ink:#e8ecff; --muted:#aab3d9; --line:#233055;
    --p1:#6ea8fe; --p2:#f59e0b; --good:#22c55e; --warn:#f59e0b; --danger:#ef4444;
    --safe-bottom: env(safe-area-inset-bottom, 0px);
  }
  html, body{
    height:100%; margin:0; background:var(--bg); color:var(--ink);
    -webkit-user-select:none; user-select:none; overscroll-behavior:none; touch-action:none;
    font:500 14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  }
  #stage{position:fixed; inset:0; width:100vw; height:100vh; display:block; background:var(--bg);}
  #hudTop{
    position:fixed; top:8px; left:50%; transform:translateX(-50%);
    display:flex; gap:8px; padding:6px; background:rgba(18,25,50,.7);
    border:1px solid var(--line); border-radius:12px; backdrop-filter: blur(6px);
    align-items:center; z-index:2; pointer-events:auto;
  }
  select, button{
    background:var(--card); color:var(--ink); border:1px solid var(--line);
    border-radius:10px; padding:8px 10px; font-weight:600;
  }
  .score{
    padding:6px 10px; border-radius:10px; border:1px solid var(--line); background:rgba(18,25,50,.7);
  }
  .p1{ color:var(--p1) } .p2{ color:var(--p2) }
  #uiBottom{
    position:fixed; inset:auto 0 0 0; padding:10px 10px calc(10px + var(--safe-bottom)) 10px;
    display:flex; justify-content:space-between; align-items:flex-end; gap:10px; z-index:2;
  }
  .stick{
    position:relative; width:140px; height:140px; border-radius:50%;
    background:radial-gradient(80px 80px at 50% 50%, rgba(255,255,255,.08), rgba(255,255,255,.02));
    border:2px solid var(--line); box-shadow:0 10px 30px rgba(0,0,0,.35) inset;
    touch-action:none;
  }
  .stick::after{ content:''; position:absolute; inset:8px; border-radius:50%; border:1px dashed rgba(255,255,255,.18); }
  .thumb{
    --x:50%; --y:50%; position:absolute; width:56px; height:56px; border-radius:50%;
    left:calc(var(--x) - 28px); top:calc(var(--y) - 28px);
    border:2px solid rgba(255,255,255,.35);
    box-shadow:0 6px 18px rgba(0,0,0,.4), 0 0 0 6px rgba(255,255,255,.12);
    transition:left .08s ease-out, top .08s ease-out;
  }
  #stickL .thumb{ background:radial-gradient(circle at 30% 30%, #90c2ff, var(--p1)); }
  #stickR .thumb{ background:radial-gradient(circle at 30% 30%, #ffd18a, var(--p2)); }
  #msg{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    padding:14px 18px; border-radius:14px; background:rgba(18,25,50,.85); border:1px solid var(--line);
    font-size:18px; display:none; z-index:3;
  }
</style>
</head>
<body>
<canvas id="stage"></canvas>

<div id="hudTop">
  <label for="mode">Mode:</label>
  <select id="mode" aria-label="Game mode">
    <option value="dodge">Dodgeballs</option>
    <option value="collect">Collect the Dots</option>
    <option value="sumo">Sumo Arena</option>
    <option value="maze">Maze</option>
  </select>
  <span class="score"><span class="p1">P1</span>: <span id="p1Score">0</span></span>
  <span class="score"><span class="p2">P2</span>: <span id="p2Score">0</span></span>
  <button id="resetBtn">Reset</button>
  <button id="pauseBtn" aria-pressed="false">⏸️ Pause</button>
</div>

<div id="uiBottom">
  <div class="stick" id="stickL" aria-label="Left joystick"><div class="thumb" id="thumbL"></div></div>
  <div class="stick" id="stickR" aria-label="Right joystick"><div class="thumb" id="thumbR"></div></div>
</div>

<div id="msg"></div>

<script>
(() => {
  // ===== Canvas setup =====
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  function fit() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fit(); addEventListener('resize', fit);

  // ===== Helpers =====
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const dist2 = (a,b) => { const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; };
  const rnd = (a,b) => a + Math.random()*(b-a);

  // ===== Game state =====
  const MODE = { DODGE:'dodge', COLLECT:'collect', SUMO:'sumo', MAZE:'maze' };
  const ui = {
    modeSel: document.getElementById('mode'),
    p1Score: document.getElementById('p1Score'),
    p2Score: document.getElementById('p2Score'),
    resetBtn: document.getElementById('resetBtn'),
    pauseBtn: document.getElementById('pauseBtn'),
    msg: document.getElementById('msg'),
  };

  const world = {
    paused: false,
    width: () => innerWidth,
    height: () => innerHeight,
    mode: MODE.DODGE,
    roundOver: false,
  };

  function basePlayer(x,y,color) {
    return {
      x, y, vx:0, vy:0, r:28, color, maxSpeed:380, accel:10, friction:0.96,
      targetX:0, targetY:0, score:0,
      // dodge
      hp:3, fireCd:0, fireRate:0.35,
      // flags
      alive:true,
    };
  }
  const p1 = basePlayer(innerWidth*0.3, innerHeight*0.6, '#6ea8fe');
  const p2 = basePlayer(innerWidth*0.7, innerHeight*0.6, '#f59e0b');

  let dots = [];      // collect mode items
  let bullets = [];   // dodgeballs bullets
  let arena = { x: innerWidth/2, y: innerHeight/2, r: Math.min(innerWidth,innerHeight)*0.38 };

  // ===== Maze data =====
  const maze = {
    cols: 0, rows: 0, size: 28, pad: 12, // size: cell px; pad: inner padding from outer border
    walls: null, // walls[y][x] = {N:true,E:true,S:true,W:true}
    start: {x:0,y:0}, end:{x:0,y:0}, goal:{x:0,y:0}, // cell coords
    lineWidth: 4
  };

  function resetCommonPositions() {
    p1.vx = p1.vy = 0; p2.vx = p2.vy = 0;
    p1.alive = p2.alive = true;
    if (world.mode === MODE.MAZE) {
      // small + slower for maze feel
      p1.r = p2.r = 16;
      p1.maxSpeed = p2.maxSpeed = 200;
      p1.accel = p2.accel = 12;
      // spawn at corners (cell centers)
      const csz = maze.size, ox = maze.pad, oy = maze.pad;
      const c1 = maze.start, c2 = maze.end;
      p1.x = ox + c1.x*csz + csz/2; p1.y = oy + c1.y*csz + csz/2;
      p2.x = ox + c2.x*csz + csz/2; p2.y = oy + c2.y*csz + csz/2;
    } else {
      // defaults for arcade modes
      p1.r = p2.r = 28;
      p1.maxSpeed = p2.maxSpeed = 380;
      p1.accel = p2.accel = 10;
      p1.x = innerWidth*0.25; p1.y = innerHeight*0.6;
      p2.x = innerWidth*0.75; p2.y = innerHeight*0.6;
    }
  }

  function resetMode(mode) {
    world.mode = mode;
    world.roundOver = false;
    bullets = []; dots = [];
    if (mode === MODE.DODGE) { p1.hp = 3; p2.hp = 3; }
    if (mode === MODE.SUMO) {
      arena.r = Math.min(innerWidth, innerHeight) * 0.38;
    }
    if (mode === MODE.COLLECT) {
      p1.score = 0; p2.score = 0;
      for (let i=0;i<10;i++) spawnDot();
    }
    if (mode === MODE.MAZE) {
      // Keep match score; generate a new maze round.
      if (typeof resetMode._firstMaze === 'undefined') { p1.score = 0; p2.score = 0; resetMode._firstMaze = true; }
      generateMaze();
    }
    resetCommonPositions();
    ui.msg.style.display = 'none';
    renderScores();
  }

  function renderScores() {
    if (world.mode === MODE.DODGE) {
      ui.p1Score.textContent = '❤'.repeat(p1.hp);
      ui.p2Score.textContent = '❤'.repeat(p2.hp);
    } else {
      ui.p1Score.textContent = p1.score;
      ui.p2Score.textContent = p2.score;
    }
  }

  // ===== Joysticks (pointer events) =====
  function makeStick(rootEl, thumbEl) {
    const STICK_R = 70;
    let activeId = null;
    let target = { x:0, y:0 };
    const setThumb = (nx,ny) => {
      const px = 50 + nx*40, py = 50 + ny*40;
      thumbEl.style.setProperty('--x', px+'%');
      thumbEl.style.setProperty('--y', py+'%');
    };
    const resetThumb = () => setThumb(0,0);

    function centered(ev) {
      const rect = rootEl.getBoundingClientRect();
      const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
      const cx = rect.width/2, cy = rect.height/2;
      return { x, y, cx, cy, max: STICK_R - 10 };
    }
    function start(ev){ if(activeId!==null) return; activeId = ev.pointerId; rootEl.setPointerCapture?.(ev.pointerId); move(ev); }
    function end(ev){ if(ev.pointerId!==activeId) return; activeId = null; rootEl.releasePointerCapture?.(ev.pointerId); target.x=0; target.y=0; resetThumb(); }
    function move(ev){
      if(ev.pointerId!==activeId) return;
      const {x,y,cx,cy,max} = centered(ev);
      let dx = x-cx, dy = y-cy;
      const d = Math.hypot(dx,dy);
      const clamped = Math.min(d, max);
      const scale = max? clamped/max : 0;
      if (d>0){ dx/=d; dy/=d; } else { dx=0; dy=0; }
      setThumb(dx*scale, dy*scale);
      target.x = dx*scale; target.y = dy*scale; // [-1..1]
    }
    ['pointerdown','pointermove','pointerup','pointercancel','lostpointercapture']
      .forEach(t=>rootEl.addEventListener(t, (ev)=>{
        if(t==='pointerdown') start(ev);
        else if(t==='pointermove') move(ev);
        else end(ev);
      }, {passive:false}));

    return target;
  }

  const stickL = makeStick(document.getElementById('stickL'), document.getElementById('thumbL'));
  const stickR = makeStick(document.getElementById('stickR'), document.getElementById('thumbR'));

  // ===== Input -> velocity targets =====
  function updateTargets() {
    p1.targetX = stickL.x * p1.maxSpeed;
    p1.targetY = stickL.y * p1.maxSpeed;
    p2.targetX = stickR.x * p2.maxSpeed;
    p2.targetY = stickR.y * p2.maxSpeed;
  }

  // ===== DODGE / COLLECT / SUMO logic (unchanged) =====
  function tryFire(player) {
    if (player.fireCd > 0) return;
    const ax = player.targetX, ay = player.targetY;
    const sp = Math.hypot(ax, ay);
    if (sp < 40) return;
    const dirx = ax/sp, diry = ay/sp;
    bullets.push({
      x: player.x + dirx * (player.r + 6),
      y: player.y + diry * (player.r + 6),
      vx: dirx * 560,
      vy: diry * 560,
      r: 6,
      owner: player
    });
    player.fireCd = player.fireRate;
  }
  function updateBullets(dt) {
    for (const b of bullets) { b.x += b.vx * dt; b.y += b.vy * dt; }
    bullets = bullets.filter(b => b.x>-20 && b.x<innerWidth+20 && b.y>-20 && b.y<innerHeight+20);
  }
  function checkBulletHits() {
    for (const b of bullets) {
      const target = (b.owner === p1) ? p2 : p1;
      const r2 = (b.r + target.r) ** 2;
      if (dist2(b, target) <= r2) {
        target.hp = Math.max(0, target.hp - 1);
        b.x = -9999;
        if (target.hp === 0 && !world.roundOver) {
          world.roundOver = true;
          const winner = (target === p1) ? 'P2' : 'P1';
          (target === p1 ? p2 : p1).score += 1;
          renderScores();
          showMsg(`${winner} wins the round!`);
        }
      }
    }
    bullets = bullets.filter(b => b.x !== -9999);
  }

  const GOAL_COLLECT = 10;
  function spawnDot() {
    const margin = 40;
    dots.push({
      x: rnd(margin, innerWidth - margin),
      y: rnd(margin, innerHeight - margin),
      r: 10,
      color: Math.random() < .5 ? '#7dd3fc' : '#a7f3d0'
    });
  }
  function updateCollect() {
    if (dots.length < 12 && Math.random() < 0.02) spawnDot();
    [p1, p2].forEach(p=>{
      for (const d of dots) {
        const r2 = (p.r + d.r) ** 2;
        if (dist2(p, d) <= r2) {
          d.x = -9999;
          p.score += 1;
          renderScores();
          if (p.score >= GOAL_COLLECT && !world.roundOver) {
            world.roundOver = true; showMsg(`${p===p1?'P1':'P2'} collected ${GOAL_COLLECT}!`);
          }
        }
      }
    });
    dots = dots.filter(d => d.x !== -9999);
  }

  function updateSumo() {
    [p1,p2].forEach(p=>{
      const dx = p.x - arena.x, dy = p.y - arena.y;
      const d = Math.hypot(dx,dy);
      const limit = arena.r - p.r;
      if (d > limit) {
        const nx = dx / d, ny = dy / d;
        p.x = arena.x + nx * limit;
        p.y = arena.y + ny * limit;
        if (d > arena.r + p.r*0.25 && !world.roundOver) {
          world.roundOver = true;
          const winner = (p===p1) ? 'P2' : 'P1';
          (p===p1 ? p2 : p1).score += 1;
          renderScores();
          showMsg(`${winner} wins the push!`);
        }
      }
    });
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const d = Math.hypot(dx,dy);
    const minDist = p1.r + p2.r;
    if (d > 0 && d < minDist) {
      const overlap = (minDist - d) / 2;
      const nx = dx / d, ny = dy / d;
      p1.x -= nx * overlap; p1.y -= ny * overlap;
      p2.x += nx * overlap; p2.y += ny * overlap;
      p1.vx -= nx * 40; p1.vy -= ny * 40;
      p2.vx += nx * 40; p2.vy += ny * 40;
    }
  }

  // ===== MAZE: generation =====
  function generateMaze() {
    // Choose a cell size that gives ~30-40 columns for phones, adjust by width.
    const targetCols = clamp(Math.floor(innerWidth / 28), 20, 42);
    maze.size = Math.max(24, Math.min(34, Math.floor(innerWidth / targetCols)));
    maze.lineWidth = Math.max(3, Math.floor(maze.size * 0.14));
    maze.pad = Math.max(12, Math.floor(Math.min(innerWidth, innerHeight) * 0.04));

    maze.cols = Math.floor((innerWidth - maze.pad*2) / maze.size);
    maze.rows = Math.floor((innerHeight - maze.pad*2) / maze.size);
    maze.cols = Math.max(8, maze.cols - (maze.cols%1));
    maze.rows = Math.max(8, maze.rows - (maze.rows%1));

    // Init walls
    maze.walls = Array.from({length: maze.rows}, ()=>Array.from({length: maze.cols}, ()=>({N:true,E:true,S:true,W:true, visited:false})));

    // Recursive backtracker
    const stack = [];
    let cx = 0, cy = 0;
    const push = (x,y)=>{ stack.push({x,y}); maze.walls[y][x].visited = true; };
    push(cx,cy);

    const dirs = [
      {dx:0,dy:-1, a:'N', b:'S'},
      {dx:1,dy:0,  a:'E', b:'W'},
      {dx:0,dy:1,  a:'S', b:'N'},
      {dx:-1,dy:0, a:'W', b:'E'}
    ];

    while (stack.length) {
      const cur = stack[stack.length-1];
      cx = cur.x; cy = cur.y;
      // shuffle dirs
      for (let i=dirs.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [dirs[i],dirs[j]]=[dirs[j],dirs[i]]; }
      let advanced = false;
      for (const d of dirs) {
        const nx = cx + d.dx, ny = cy + d.dy;
        if (nx>=0 && nx<maze.cols && ny>=0 && ny<maze.rows && !maze.walls[ny][nx].visited) {
          // knock wall
          maze.walls[cy][cx][d.a] = false;
          maze.walls[ny][nx][d.b] = false;
          push(nx,ny);
          advanced = true;
          break;
        }
      }
      if (!advanced) stack.pop();
    }

    // Start/End corners and goal
    maze.start = {x:0,y:0};
    maze.end   = {x:maze.cols-1,y:maze.rows-1};
    maze.goal  = {x: (maze.cols/2)|0, y: (maze.rows/2)|0};
  }

  // ===== MAZE: movement & collision =====
  function moveInMaze(p, dt) {
    // axis-wise movement with wall checks against current cell
    const s = maze.size, ox = maze.pad, oy = maze.pad;
    // Helper to get cell index from position
    const toCell = (x,y)=>({ cx: clamp(Math.floor((x-ox)/s), 0, maze.cols-1),
                             cy: clamp(Math.floor((y-oy)/s), 0, maze.rows-1) });

    // desired step
    let nx = p.x + p.vx * dt;
    let ny = p.y + p.vy * dt;

    // Resolve X
    if (p.vx !== 0) {
      const dir = Math.sign(p.vx);
      const {cx,cy} = toCell(p.x, p.y);
      const cell = maze.walls[cy][cx];
      if (dir > 0) {
        // moving right: check East wall of current cell
        if (cell.E) {
          const wallX = ox + (cx+1)*s; // inner edge
          const maxX = wallX - p.r - 1;
          nx = Math.min(nx, maxX);
        }
      } else {
        // moving left: check West wall
        if (cell.W) {
          const wallX = ox + cx*s;
          const minX = wallX + p.r + 1;
          nx = Math.max(nx, minX);
        }
      }
      // If we crossed into a new cell, also check that cell's opposite wall (corner safety)
      const {cx:ncx, cy:ncy} = toCell(nx, p.y);
      if (ncx !== cx || ncy !== cy) {
        const ncell = maze.walls[ncy][ncx];
        if (dir > 0 && ncell.W) {
          const wallX = ox + ncx*s;
          const minX = wallX + p.r + 1;
          nx = Math.max(nx, minX);
        } else if (dir < 0 && ncell.E) {
          const wallX = ox + (ncx+1)*s;
          const maxX = wallX - p.r - 1;
          nx = Math.min(nx, maxX);
        }
      }
      p.x = nx;
    }

    // Resolve Y
    if (p.vy !== 0) {
      const dir = Math.sign(p.vy);
      const {cx,cy} = toCell(p.x, p.y);
      const cell = maze.walls[cy][cx];
      if (dir > 0) {
        // moving down: check South wall
        if (cell.S) {
          const wallY = oy + (cy+1)*s;
          const maxY = wallY - p.r - 1;
          ny = Math.min(ny, maxY);
        }
      } else {
        // moving up: check North wall
        if (cell.N) {
          const wallY = oy + cy*s;
          const minY = wallY + p.r + 1;
          ny = Math.max(ny, minY);
        }
      }
      const {cx:ncx, cy:ncy} = toCell(p.x, ny);
      if (ncx !== cx || ncy !== cy) {
        const ncell = maze.walls[ncy][ncx];
        if (dir > 0 && ncell.N) {
          const wallY = oy + ncy*s;
          const minY = wallY + p.r + 1;
          ny = Math.max(ny, minY);
        } else if (dir < 0 && ncell.S) {
          const wallY = oy + (ncy+1)*s;
          const maxY = wallY - p.r - 1;
          ny = Math.min(ny, maxY);
        }
      }
      p.y = ny;
    }

    // Clamp to maze bounds
    const minX = ox + p.r + 1, maxX = ox + maze.cols*s - p.r - 1;
    const minY = oy + p.r + 1, maxY = oy + maze.rows*s - p.r - 1;
    p.x = clamp(p.x, minX, maxX);
    p.y = clamp(p.y, minY, maxY);
  }

  // ===== Rendering =====
  function drawGrid() {
    const s = 40; ctx.save(); ctx.strokeStyle='rgba(255,255,255,.05)'; ctx.lineWidth=1;
    for (let x=0;x<innerWidth;x+=s){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,innerHeight); ctx.stroke(); }
    for (let y=0;y<innerHeight;y+=s){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(innerWidth,y); ctx.stroke(); }
    ctx.restore();
  }
  function drawSmiley(p) {
    const r = p.r, x = p.x, y = p.y;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
    const grd = ctx.createRadialGradient(x - r*0.4, y - r*0.4, r*0.2, x, y, r);
    if (p===p1){ grd.addColorStop(0, '#bfe0ff'); grd.addColorStop(1, '#6ea8fe'); }
    else { grd.addColorStop(0, '#ffd7a3'); grd.addColorStop(1, '#f59e0b'); }
    ctx.fillStyle = grd; ctx.fill();
    ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.stroke();
    // eyes
    ctx.fillStyle='#1a1a1a';
    ctx.beginPath(); ctx.arc(x - r*0.35, y - r*0.2, r*0.12, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + r*0.35, y - r*0.2, r*0.12, 0, Math.PI*2); ctx.fill();
    // mouth
    const spd = Math.hypot(p.vx, p.vy);
    const smile = Math.min(0.7, 0.2 + spd / Math.max(1,p.maxSpeed) * 0.5);
    ctx.strokeStyle='#1a1a1a'; ctx.lineWidth=3; ctx.beginPath();
    const mW = r*0.9, mH = r*smile*0.6;
    ctx.moveTo(x - mW/2, y + r*0.2);
    ctx.quadraticCurveTo(x, y + r*0.2 + mH, x + mW/2, y + r*0.2);
    ctx.stroke();
  }
  function drawBullets() {
    ctx.save(); ctx.fillStyle='#e8ecff';
    for (const b of bullets) { ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
  function drawDots() {
    for (const d of dots) {
      ctx.fillStyle = d.color; ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,Math.PI*2); ctx.fill();
    }
  }
  function drawArena() {
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.arc(arena.x, arena.y, arena.r, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  // ===== MAZE: render walls + goal =====
  function drawMaze() {
    if (!maze.walls) return;
    const s = maze.size, ox = maze.pad, oy = maze.pad;
    ctx.save();
    ctx.lineWidth = maze.lineWidth;
    ctx.strokeStyle = 'rgba(232,236,255,0.85)';
    ctx.lineCap = 'square';

    // Outer border
    ctx.beginPath();
    ctx.rect(ox, oy, maze.cols*s, maze.rows*s);
    ctx.stroke();

    // Cell walls
    ctx.beginPath();
    for (let y=0; y<maze.rows; y++) {
      for (let x=0; x<maze.cols; x++) {
        const w = maze.walls[y][x];
        const px = ox + x*s, py = oy + y*s;
        if (w.N) { ctx.moveTo(px, py); ctx.lineTo(px+s, py); }
        if (w.E) { ctx.moveTo(px+s, py); ctx.lineTo(px+s, py+s); }
        if (w.S) { ctx.moveTo(px, py+s); ctx.lineTo(px+s, py+s); }
        if (w.W) { ctx.moveTo(px, py); ctx.lineTo(px, py+s); }
      }
    }
    ctx.stroke();

    // Goal star
    const gx = ox + maze.goal.x*s + s/2;
    const gy = oy + maze.goal.y*s + s/2;
    drawStar(gx, gy, Math.max(8, Math.floor(s*0.28)), 5);
    ctx.restore();
  }

  function drawStar(x, y, r, spikes) {
    const outer = r, inner = r*0.5;
    let rot = Math.PI/2 * 3, step = Math.PI / spikes;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x, y - outer);
    for (let i=0;i<spikes;i++){
      let cx = x + Math.cos(rot) * outer;
      let cy = y + Math.sin(rot) * outer;
      ctx.lineTo(cx, cy);
      rot += step;

      cx = x + Math.cos(rot) * inner;
      cy = y + Math.sin(rot) * inner;
      ctx.lineTo(cx, cy);
      rot += step;
    }
    ctx.lineTo(x, y - outer);
    ctx.closePath();
    ctx.fillStyle = '#ffd54d';
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 2;
    ctx.fill(); ctx.stroke();
    ctx.restore();
  }

  function showMsg(text) {
    ui.msg.textContent = text + ' — Tap Reset';
    ui.msg.style.display = 'block';
  }

  // ===== Main loop =====
  let last = performance.now();
  function frame(now){
    const dt = Math.min(0.035, (now-last)/1000); last = now;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Background grid (subtle)
    if (world.mode !== MODE.MAZE) drawGrid();

    if (!world.paused && !world.roundOver) {
      updateTargets();

      // accelerate toward target velocity
      [p1,p2].forEach(p=>{
        const ax = (p.targetX - p.vx) * p.accel * dt;
        const ay = (p.targetY - p.vy) * p.accel * dt;
        p.vx += ax; p.vy += ay;
        if (Math.abs(p.targetX)+Math.abs(p.targetY) < 1) { p.vx *= p.friction; p.vy *= p.friction; }
      });

      if (world.mode === MODE.MAZE) {
        drawMaze(); // draw under players
        moveInMaze(p1, dt);
        moveInMaze(p2, dt);
        checkMazeGoal();
      } else {
        // Arcade movement & walls
        updatePlayer(p1, dt);
        updatePlayer(p2, dt);

        if (world.mode === MODE.DODGE) {
          tryFire(p1); tryFire(p2);
          updateBullets(dt);
          checkBulletHits();
        } else if (world.mode === MODE.COLLECT) {
          updateCollect();
        } else if (world.mode === MODE.SUMO) {
          drawArena();
          updateSumo();
        }
      }
    } else {
      if (world.mode === MODE.SUMO) drawArena();
      if (world.mode === MODE.MAZE) drawMaze();
    }

    // Render entities
    if (world.mode === MODE.COLLECT) drawDots();
    if (world.mode === MODE.DODGE) drawBullets();
    drawSmiley(p1); drawSmiley(p2);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ===== Maze goal check =====
  const MAZE_GOAL_WIN = 3;
  function checkMazeGoal() {
    const s = maze.size, ox = maze.pad, oy = maze.pad;
    const gx = ox + maze.goal.x*s + s/2;
    const gy = oy + maze.goal.y*s + s/2;
    const gr = Math.max(10, Math.floor(s*0.32));

    // Touch if center within (gr + player.r)
    const r1 = (p1.r + gr);
    const r2 = (p2.r + gr);

    const hit1 = ((p1.x-gx)**2 + (p1.y-gy)**2) <= r1*r1;
    const hit2 = ((p2.x-gx)**2 + (p2.y-gy)**2) <= r2*r2;

    if (!hit1 && !hit2) return;

    // Tie-break: earliest touch (this frame), else closer center wins
    let winner = null;
    if (hit1 && !hit2) winner = 'P1';
    else if (!hit1 && hit2) winner = 'P2';
    else {
      const d1 = Math.hypot(p1.x-gx, p1.y-gy);
      const d2 = Math.hypot(p2.x-gx, p2.y-gy);
      winner = (d1 <= d2) ? 'P1' : 'P2';
    }

    if (winner === 'P1') p1.score += 1; else p2.score += 1;
    renderScores();

    if ((p1.score >= MAZE_GOAL_WIN || p2.score >= MAZE_GOAL_WIN) && !world.roundOver) {
      world.roundOver = true;
      showMsg(`${winner} wins the match!`);
      return;
    }

    // New round: regenerate maze + respawn
    generateMaze();
    resetCommonPositions();
  }

  // ===== Physics & update for arcade modes (unchanged) =====
  function updatePlayer(p, dt) {
    const ax = (p.targetX - p.vx) * p.accel * dt;
    const ay = (p.targetY - p.vy) * p.accel * dt;
    p.vx += ax; p.vy += ay;
    if (Math.abs(p.targetX)+Math.abs(p.targetY) < 1) { p.vx *= p.friction; p.vy *= p.friction; }
    p.x += p.vx * dt; p.y += p.vy * dt;

    if (world.mode !== MODE.SUMO) {
      const r = p.r;
      const maxX = innerWidth - r, maxY = innerHeight - r;
      if (p.x < r){ p.x=r; if(p.vx<0) p.vx=0; }
      if (p.y < r){ p.y=r; if(p.vy<0) p.vy=0; }
      if (p.x > maxX){ p.x=maxX; if(p.vx>0) p.vx=0; }
      if (p.y > maxY){ p.y=maxY; if(p.vy>0) p.vy=0; }
    }
    p.fireCd = Math.max(0, p.fireCd - dt);
  }

  // ===== UI events =====
  ui.modeSel.addEventListener('change', (e)=>{
    // Reset for selected mode
    resetMode(e.target.value);
  });
  ui.resetBtn.addEventListener('click', ()=> resetMode(world.mode));
  ui.pauseBtn.addEventListener('click', ()=>{
    world.paused = !world.paused;
    ui.pauseBtn.textContent = world.paused ? '▶️ Resume' : '⏸️ Pause';
    ui.pauseBtn.setAttribute('aria-pressed', String(world.paused));
  });

  // initial
  resetMode(MODE.DODGE);
})();
</script>
</body>
</html>