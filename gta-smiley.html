<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Smiley Joystick</title>
<meta name="description" content="Move a smiley smoothly with a virtual joystick. iOS-friendly." />
<style>
  :root{
    --bg:#0b1020; --card:#121932; --ink:#e8ecff; --muted:#aab3d9;
    --line:#233055; --accent:#6ea8fe; --accent2:#90c2ff; --accent3:#f59e0b;
    --safe-bottom: env(safe-area-inset-bottom, 0px);
  }
  html, body {
    height:100%; margin:0; background:var(--bg); color:var(--ink);
    -webkit-user-select:none; user-select:none; overscroll-behavior:none;
    touch-action:none; /* critical: enable multi-touch without scrolling */
  }
  #ui {
    position:fixed; inset:auto 0 0 0; padding:10px calc(10px) calc(10px + var(--safe-bottom)) 10px;
    display:flex; justify-content:space-between; align-items:flex-end; pointer-events:none;
    gap:10px;
  }
  /* Canvas fills the screen behind UI */
  #stage { position:fixed; inset:0; display:block; width:100vw; height:100vh; background:var(--bg); }

  /* Joystick */
  .stick {
    position:relative; width:140px; height:140px; border-radius:50%;
    background:radial-gradient(80px 80px at 50% 50%, rgba(110,168,254,.15), rgba(110,168,254,.05));
    border:2px solid var(--line);
    box-shadow:0 0 0 2px rgba(110,168,254,.1) inset, 0 10px 30px rgba(0,0,0,.35);
    pointer-events:auto; /* accept input */
    touch-action:none;
  }
  .stick::after {
    content:''; position:absolute; inset:8px; border-radius:50%;
    border:1px dashed rgba(144,194,255,.25);
  }
  .thumb {
    --x: 50%; --y: 50%;
    position:absolute; width:56px; height:56px; border-radius:50%;
    left:calc(var(--x) - 28px); top:calc(var(--y) - 28px);
    background:radial-gradient(circle at 30% 30%, var(--accent2), var(--accent));
    border:2px solid rgba(255,255,255,.35);
    box-shadow:0 6px 18px rgba(0,0,0,.4), 0 0 0 6px rgba(110,168,254,.15);
    transition: left .08s ease-out, top .08s ease-out;
  }

  /* Buttons (pause/reset) */
  .btns { display:flex; gap:8px; pointer-events:auto; }
  button {
    background:var(--card); color:var(--ink); border:1px solid var(--line);
    padding:10px 14px; border-radius:12px; font:600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }
  button:active { transform:translateY(1px); }
  .hint {
    position:fixed; top:10px; left:50%; transform:translateX(-50%);
    padding:8px 12px; background:rgba(18,25,50,.7); border:1px solid var(--line); border-radius:10px;
    font:500 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:var(--muted);
  }
</style>
</head>
<body>
<canvas id="stage"></canvas>

<div class="hint">Drag the joystick to move üòä ‚Äî Works on iPhone/iPad and desktop (mouse).</div>

<div id="ui">
  <div class="stick" id="stick">
    <div class="thumb" id="thumb"></div>
  </div>
  <div class="btns">
    <button id="pauseBtn" aria-pressed="false">‚è∏Ô∏è Pause</button>
    <button id="resetBtn">üîÑ Reset</button>
  </div>
</div>

<script>
(() => {
  // ---------- Canvas setup ----------
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  function fitCanvas() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width  = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  fitCanvas();
  addEventListener('resize', fitCanvas);

  // ---------- Game state ----------
  const state = {
    pos: { x: window.innerWidth * 0.5, y: window.innerHeight * 0.5 },
    vel: { x: 0, y: 0 },
    radius: 28, // smiley radius (px)
    maxSpeed: 380, // px/sec at full deflection
    accel: 10.0,   // how fast velocity approaches target (larger = snappier)
    friction: 0.96, // applied when no input
    target: { x: 0, y: 0 }, // desired velocity from stick
    paused: false
  };

  // ---------- Joystick logic ----------
  const stick = document.getElementById('stick');
  const thumb = document.getElementById('thumb');
  const STICK_R = 70; // px, outer circle radius (matches CSS ~140x140)
  const center = { x: 0, y: 0 };
  let activePointerId = null;

  function setThumb(nx, ny) {
    // nx, ny in [-1,1] relative to center
    const px = 50 + nx * 40; // visual range (percent in the 8px inset ring)
    const py = 50 + ny * 40;
    thumb.style.setProperty('--x', px + '%');
    thumb.style.setProperty('--y', py + '%');
  }
  function resetThumb() { setThumb(0, 0); }

  function pointerPosInStick(ev) {
    const rect = stick.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    // Convert to centered coords
    center.x = rect.width / 2;
    center.y = rect.height / 2;
    return { x, y, rect };
  }

  function handleStart(ev) {
    if (activePointerId !== null) return; // ignore additional touches
    activePointerId = ev.pointerId;
    stick.setPointerCapture?.(ev.pointerId);
    updateFromEvent(ev);
  }

  function handleMove(ev) {
    if (ev.pointerId !== activePointerId) return;
    updateFromEvent(ev);
  }

  function handleEnd(ev) {
    if (ev.pointerId !== activePointerId) return;
    activePointerId = null;
    stick.releasePointerCapture?.(ev.pointerId);
    state.target.x = 0; state.target.y = 0;
    resetThumb();
  }

  function updateFromEvent(ev) {
    const { x, y } = pointerPosInStick(ev);
    let dx = x - center.x;
    let dy = y - center.y;
    const dist = Math.hypot(dx, dy);
    const max = STICK_R - 10; // visual clamp inside border
    const clamped = dist > max ? max : dist;
    const scale = (clamped === 0) ? 0 : (clamped / max);
    // Normalized direction (avoid NaN)
    if (dist > 0) { dx /= dist; dy /= dist; } else { dx = 0; dy = 0; }
    // Visual thumb position
    setThumb(dx * scale, dy * scale);
    // Convert to desired velocity (invert Y because screen coords)
    state.target.x = dx * scale * state.maxSpeed;
    state.target.y = dy * scale * state.maxSpeed;
  }

  // Use Pointer Events (covers touch + mouse). Ensure element accepts them.
  ['pointerdown','pointermove','pointerup','pointercancel','lostpointercapture']
    .forEach(type => stick.addEventListener(type, (ev) => {
      if (type === 'pointerdown') handleStart(ev);
      else if (type === 'pointermove') handleMove(ev);
      else handleEnd(ev);
    }, { passive:false }));

  // Desktop fallback: allow holding mouse anywhere on stick
  // (already covered by pointer events above)

  // ---------- Buttons ----------
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  pauseBtn.addEventListener('click', () => {
    state.paused = !state.paused;
    pauseBtn.textContent = state.paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
    pauseBtn.setAttribute('aria-pressed', String(state.paused));
  });
  resetBtn.addEventListener('click', () => {
    state.pos.x = window.innerWidth * 0.5;
    state.pos.y = window.innerHeight * 0.5;
    state.vel.x = state.vel.y = 0;
  });

  // ---------- Game loop ----------
  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.035, (now - last) / 1000); // cap dt (35ms) for stability
    last = now;

    if (!state.paused) {
      // Ease current velocity toward target velocity
      const ax = (state.target.x - state.vel.x) * state.accel * dt;
      const ay = (state.target.y - state.vel.y) * state.accel * dt;
      state.vel.x += ax;
      state.vel.y += ay;

      // Apply friction when no input
      if (activePointerId === null) {
        state.vel.x *= state.friction;
        state.vel.y *= state.friction;
      }

      // Integrate position
      state.pos.x += state.vel.x * dt;
      state.pos.y += state.vel.y * dt;

      // Collide with canvas bounds (hard walls)
      const r = state.radius;
      const maxX = window.innerWidth - r;
      const maxY = window.innerHeight - r;
      if (state.pos.x < r) { state.pos.x = r; if (state.vel.x < 0) state.vel.x = 0; }
      if (state.pos.y < r) { state.pos.y = r; if (state.vel.y < 0) state.vel.y = 0; }
      if (state.pos.x > maxX) { state.pos.x = maxX; if (state.vel.x > 0) state.vel.x = 0; }
      if (state.pos.y > maxY) { state.pos.y = maxY; if (state.vel.y > 0) state.vel.y = 0; }
    }

    // Render
    draw();
    requestAnimationFrame(loop);
  }

  function draw() {
    // Clear with subtle grid background
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawGrid();

    // Smiley
    const { x, y } = state.pos;
    const r = state.radius;

    // body
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    const grd = ctx.createRadialGradient(x - r*0.4, y - r*0.4, r*0.2, x, y, r);
    grd.addColorStop(0, '#ffe58a');
    grd.addColorStop(1, '#f59e0b');
    ctx.fillStyle = grd;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,.25)';
    ctx.stroke();

    // eyes
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath(); ctx.arc(x - r*0.35, y - r*0.2, r*0.12, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + r*0.35, y - r*0.2, r*0.12, 0, Math.PI*2); ctx.fill();

    // mouth (slight tilt per velocity)
    const spd = Math.hypot(state.vel.x, state.vel.y);
    const smile = Math.min(0.7, 0.2 + spd / state.maxSpeed * 0.5); // curve by speed
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 3;
    ctx.beginPath();
    const mW = r*0.9, mH = r*smile*0.6;
    ctx.moveTo(x - mW/2, y + r*0.2);
    ctx.quadraticCurveTo(x, y + r*0.2 + mH, x + mW/2, y + r*0.2);
    ctx.stroke();
  }

  function drawGrid() {
    const s = 40; // spacing
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,.05)';
    ctx.lineWidth = 1;
    const w = window.innerWidth, h = window.innerHeight;
    for (let gx = 0; gx < w; gx += s) {
      ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, h); ctx.stroke();
    }
    for (let gy = 0; gy < h; gy += s) {
      ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(w, gy); ctx.stroke();
    }
    ctx.restore();
  }

  resetThumb();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>