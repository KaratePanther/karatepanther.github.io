<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Smiley Duo Arcade ‚Äî 5 Modes</title>
<meta name="description" content="Two-player virtual joysticks with Dodgeballs, Collect the Dots, Sumo Arena, Maze, and Bomber." />
<style>
  :root{
    --bg:#0b1020; --card:#121932; --ink:#e8ecff; --muted:#aab3d9; --line:#233055;
    --p1:#6ea8fe; --p2:#f59e0b; --good:#22c55e; --warn:#f59e0b; --danger:#ef4444;
    --safe-bottom: env(safe-area-inset-bottom, 0px);
  }
  html, body{
    height:100%; margin:0; background:var(--bg); color:var(--ink);
    -webkit-user-select:none; user-select:none; overscroll-behavior:none; touch-action:none;
    font:500 14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  }
  #stage{position:fixed; inset:0; width:100vw; height:100vh; display:block; background:var(--bg);}
  #hudTop{
    position:fixed; top:8px; left:50%; transform:translateX(-50%);
    display:flex; gap:8px; padding:6px; background:rgba(18,25,50,.7);
    border:1px solid var(--line); border-radius:12px; backdrop-filter: blur(6px);
    align-items:center; z-index:3; pointer-events:auto;
  }
  select, button{
    background:var(--card); color:var(--ink); border:1px solid var(--line);
    border-radius:10px; padding:8px 10px; font-weight:600;
  }
  .score{
    padding:6px 10px; border-radius:10px; border:1px solid var(--line); background:rgba(18,25,50,.7);
  }
  .p1{ color:var(--p1) } .p2{ color:var(--p2) }
  #uiBottom{
    position:fixed; inset:auto 0 0 0; padding:10px 10px calc(10px + var(--safe-bottom)) 10px;
    display:flex; justify-content:space-between; align-items:flex-end; gap:10px; z-index:2;
  }
  .stick{
    position:relative; width:140px; height:140px; border-radius:50%;
    background:radial-gradient(80px 80px at 50% 50%, rgba(255,255,255,.08), rgba(255,255,255,.02));
    border:2px solid var(--line); box-shadow:0 10px 30px rgba(0,0,0,.35) inset;
    touch-action:none;
  }
  .stick::after{ content:''; position:absolute; inset:8px; border-radius:50%; border:1px dashed rgba(255,255,255,.18); }
  .thumb{
    --x:50%; --y:50%; position:absolute; width:56px; height:56px; border-radius:50%;
    left:calc(var(--x) - 28px); top:calc(var(--y) - 28px);
    border:2px solid rgba(255,255,255,.35);
    box-shadow:0 6px 18px rgba(0,0,0,.4), 0 0 0 6px rgba(255,255,255,.12);
    transition:left .08s ease-out, top .08s ease-out;
  }
  #stickL .thumb{ background:radial-gradient(circle at 30% 30%, #90c2ff, var(--p1)); }
  #stickR .thumb{ background:radial-gradient(circle at 30% 30%, #ffd18a, var(--p2)); }
  #msg{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    padding:14px 18px; border-radius:14px; background:rgba(18,25,50,.85); border:1px solid var(--line);
    font-size:18px; display:none; z-index:4;
  }
  /* Bomber buttons */
  .pad{
    display:flex; gap:10px; align-items:flex-end;
  }
  .bombBtn{
    min-width:64px; padding:10px 12px; font-size:13px;
    border-radius:12px; border:1px solid var(--line); background:rgba(18,25,50,.8);
  }
  /* Small hint labels */
  .hint{
    position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
    color:var(--muted); font-size:12px; opacity:.8; z-index:1; pointer-events:none;
  }
</style>
</head>
<body>
<canvas id="stage"></canvas>

<div id="hudTop">
  <label for="mode">Mode:</label>
  <select id="mode" aria-label="Game mode">
    <option value="dodge">Dodgeballs</option>
    <option value="collect">Collect the Dots</option>
    <option value="sumo">Sumo Arena</option>
    <option value="maze">Maze</option>
    <option value="bomber">Bomber</option>
  </select>
  <span class="score"><span class="p1">P1</span>: <span id="p1Score">0</span></span>
  <span class="score"><span class="p2">P2</span>: <span id="p2Score">0</span></span>
  <button id="resetBtn">Reset</button>
  <button id="pauseBtn" aria-pressed="false">‚è∏Ô∏è Pause</button>
</div>

<div id="uiBottom">
  <div class="pad">
    <div class="stick" id="stickL" aria-label="Left joystick"><div class="thumb" id="thumbL"></div></div>
    <button id="bombL" class="bombBtn">üí£ P1</button>
  </div>
  <div class="pad">
    <button id="bombR" class="bombBtn">üí£ P2</button>
    <div class="stick" id="stickR" aria-label="Right joystick"><div class="thumb" id="thumbR"></div></div>
  </div>
</div>

<div id="msg"></div>
<div class="hint" id="hint"></div>

<script>
(() => {
  // ===== Canvas setup =====
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  function fit() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fit(); addEventListener('resize', fit);

  // ===== Helpers =====
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const dist2 = (a,b) => { const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; };
  const rnd = (a,b) => a + Math.random()*(b-a);
  const chance = p => Math.random() < p;

  // ===== Game state =====
  const MODE = { DODGE:'dodge', COLLECT:'collect', SUMO:'sumo', MAZE:'maze', BOMBER:'bomber' };
  const ui = {
    modeSel: document.getElementById('mode'),
    p1Score: document.getElementById('p1Score'),
    p2Score: document.getElementById('p2Score'),
    resetBtn: document.getElementById('resetBtn'),
    pauseBtn: document.getElementById('pauseBtn'),
    msg: document.getElementById('msg'),
    bombL: document.getElementById('bombL'),
    bombR: document.getElementById('bombR'),
    hint: document.getElementById('hint'),
  };

  const world = {
    paused: false,
    width: () => innerWidth,
    height: () => innerHeight,
    mode: MODE.DODGE,
    roundOver: false,
  };

  function basePlayer(x,y,color) {
    return {
      x, y, vx:0, vy:0, r:28, color, maxSpeed:380, accel:10, friction:0.96,
      targetX:0, targetY:0, score:0,
      // dodge
      hp:3, fireCd:0, fireRate:0.35,
      // bomber stats
      alive:true,
      bombsCarried:1, bombsMax:1, flame:2, speedBoost:0, canKick:false, canPass:false,
      bombCooldown:0
    };
  }
  const p1 = basePlayer(innerWidth*0.3, innerHeight*0.6, '#6ea8fe');
  const p2 = basePlayer(innerWidth*0.7, innerHeight*0.6, '#f59e0b');

  let dots = [];      // collect mode items
  let bullets = [];   // dodgeballs bullets
  let arena = { x: innerWidth/2, y: innerHeight/2, r: Math.min(innerWidth,innerHeight)*0.38 };

  // ===== Maze data =====
  const maze = {
    cols: 0, rows: 0, size: 28, pad: 12,
    walls: null, start: {x:0,y:0}, end:{x:0,y:0}, goal:{x:0,y:0},
    lineWidth: 4
  };

  // ===== Bomber data =====
  const bomber = {
    cols: 15, rows: 13, tile: 40, ox: 0, oy: 0,
    grid: [], // 0 empty, 1 solid, 2 crate
    powerups: [], // {x,y,type}
    bombs: [], // {x,y,owner,fuse,range,solidAt:time, moving:{dx,dy}}
    flames: [], // {x,y,t}
    roundWinsTo: 3,
    suddenDeathAt: 60, sdTimer: 0, ring: 0
  };

  // ===== Common resets =====
  function resetCommonPositions() {
    p1.vx = p1.vy = 0; p2.vx = p2.vy = 0;
    p1.alive = p2.alive = true;
    if (world.mode === MODE.MAZE) {
      p1.r = p2.r = 16;
      p1.maxSpeed = p2.maxSpeed = 200;
      p1.accel = p2.accel = 12;
      const csz = maze.size, ox = maze.pad, oy = maze.pad;
      const c1 = maze.start, c2 = maze.end;
      p1.x = ox + c1.x*csz + csz/2; p1.y = oy + c1.y*csz + csz/2;
      p2.x = ox + c2.x*csz + csz/2; p2.y = oy + c2.y*csz + csz/2;
    } else if (world.mode === MODE.BOMBER) {
      p1.r = p2.r = Math.floor(bomber.tile*0.35);
      const baseSpeed = 180;
      p1.maxSpeed = p2.maxSpeed = baseSpeed;
      p1.accel = p2.accel = 14;
      // place at corners
      const c1 = {x:1,y:1}, c2 = {x:bomber.cols-2, y:bomber.rows-2};
      p1.x = bomber.ox + c1.x*bomber.tile + bomber.tile/2;
      p1.y = bomber.oy + c1.y*bomber.tile + bomber.tile/2;
      p2.x = bomber.ox + c2.x*bomber.tile + bomber.tile/2;
      p2.y = bomber.oy + c2.y*bomber.tile + bomber.tile/2;
      // reset stats
      [p1,p2].forEach(p=>{
        p.bombsMax = 1; p.bombsCarried = 1; p.flame = 2;
        p.speedBoost = 0; p.canKick = false; p.canPass = false; p.bombCooldown = 0;
      });
    } else {
      p1.r = p2.r = 28;
      p1.maxSpeed = p2.maxSpeed = 380;
      p1.accel = p2.accel = 10;
      p1.x = innerWidth*0.25; p1.y = innerHeight*0.6;
      p2.x = innerWidth*0.75; p2.y = innerHeight*0.6;
    }
  }

  function renderScores() {
    if (world.mode === MODE.DODGE) {
      ui.p1Score.textContent = '‚ù§'.repeat(p1.hp);
      ui.p2Score.textContent = '‚ù§'.repeat(p2.hp);
    } else {
      ui.p1Score.textContent = p1.score;
      ui.p2Score.textContent = p2.score;
    }
  }

  function resetMode(mode) {
    world.mode = mode;
    world.roundOver = false;
    bullets = []; dots = [];
    ui.msg.style.display = 'none';
    ui.hint.textContent = '';

    if (mode === MODE.DODGE) { p1.hp = 3; p2.hp = 3; }
    if (mode === MODE.SUMO) {
      arena.r = Math.min(innerWidth, innerHeight) * 0.38;
    }
    if (mode === MODE.COLLECT) {
      p1.score = 0; p2.score = 0;
      for (let i=0;i<10;i++) spawnDot();
    }
    if (mode === MODE.MAZE) {
      if (typeof resetMode._firstMaze === 'undefined') { p1.score = 0; p2.score = 0; resetMode._firstMaze = true; }
      generateMaze();
    }
    if (mode === MODE.BOMBER) {
      if (typeof resetMode._firstBomber === 'undefined') { p1.score = 0; p2.score = 0; resetMode._firstBomber = true; }
      buildBomberArena();
      ui.hint.textContent = 'Controls: P1 WASD + Space ¬∑ P2 Arrows + Enter ¬∑ Tap üí£ or use joysticks + buttons';
    }
    resetCommonPositions();
    renderScores();
  }

  // ===== Joysticks =====
  function makeStick(rootEl, thumbEl) {
    const STICK_R = 70;
    let activeId = null;
    let target = { x:0, y:0 };
    const setThumb = (nx,ny) => {
      const px = 50 + nx*40, py = 50 + ny*40;
      thumbEl.style.setProperty('--x', px+'%');
      thumbEl.style.setProperty('--y', py+'%');
    };
    const resetThumb = () => setThumb(0,0);

    function centered(ev) {
      const rect = rootEl.getBoundingClientRect();
      const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
      const cx = rect.width/2, cy = rect.height/2;
      return { x, y, cx, cy, max: STICK_R - 10 };
    }
    function start(ev){ if(activeId!==null) return; activeId = ev.pointerId; rootEl.setPointerCapture?.(ev.pointerId); move(ev); ev.preventDefault(); }
    function end(ev){ if(ev.pointerId!==activeId) return; activeId = null; rootEl.releasePointerCapture?.(ev.pointerId); target.x=0; target.y=0; resetThumb(); ev.preventDefault(); }
    function move(ev){
      if(ev.pointerId!==activeId) return;
      const {x,y,cx,cy,max} = centered(ev);
      let dx = x-cx, dy = y-cy;
      const d = Math.hypot(dx,dy);
      const clamped = Math.min(d, max);
      const scale = max? clamped/max : 0;
      if (d>0){ dx/=d; dy/=d; } else { dx=0; dy=0; }
      setThumb(dx*scale, dy*scale);
      target.x = dx*scale; target.y = dy*scale; // [-1..1]
      ev.preventDefault();
    }
    ['pointerdown','pointermove','pointerup','pointercancel','lostpointercapture']
      .forEach(t=>rootEl.addEventListener(t, (ev)=>{
        if(t==='pointerdown') start(ev);
        else if(t==='pointermove') move(ev);
        else end(ev);
      }, {passive:false}));

    return target;
  }

  const stickL = makeStick(document.getElementById('stickL'), document.getElementById('thumbL'));
  const stickR = makeStick(document.getElementById('stickR'), document.getElementById('thumbR'));

  function updateTargets() {
    p1.targetX = stickL.x * p1.maxSpeed * (1 + p1.speedBoost*0.12);
    p1.targetY = stickL.y * p1.maxSpeed * (1 + p1.speedBoost*0.12);
    p2.targetX = stickR.x * p2.maxSpeed * (1 + p2.speedBoost*0.12);
    p2.targetY = stickR.y * p2.maxSpeed * (1 + p2.speedBoost*0.12);
  }

  // ===== DODGE / COLLECT / SUMO logic =====
  function tryFire(player) {
    if (player.fireCd > 0) return;
    const ax = player.targetX, ay = player.targetY;
    const sp = Math.hypot(ax, ay);
    if (sp < 40) return;
    const dirx = ax/sp, diry = ay/sp;
    bullets.push({
      x: player.x + dirx * (player.r + 6),
      y: player.y + diry * (player.r + 6),
      vx: dirx * 560,
      vy: diry * 560,
      r: 6,
      owner: player
    });
    player.fireCd = player.fireRate;
  }
  function updateBullets(dt) {
    for (const b of bullets) { b.x += b.vx * dt; b.y += b.vy * dt; }
    bullets = bullets.filter(b => b.x>-20 && b.x<innerWidth+20 && b.y>-20 && b.y<innerHeight+20);
  }
  function checkBulletHits() {
    for (const b of bullets) {
      const target = (b.owner === p1) ? p2 : p1;
      const r2 = (b.r + target.r) ** 2;
      if (dist2(b, target) <= r2) {
        target.hp = Math.max(0, target.hp - 1);
        b.x = -9999;
        if (target.hp === 0 && !world.roundOver) {
          world.roundOver = true;
          const winner = (target === p1) ? 'P2' : 'P1';
          (target === p1 ? p2 : p1).score += 1;
          renderScores();
          showMsg(`${winner} wins the round!`);
        }
      }
    }
    bullets = bullets.filter(b => b.x !== -9999);
  }

  const GOAL_COLLECT = 10;
  function spawnDot() {
    const margin = 40;
    dots.push({
      x: rnd(margin, innerWidth - margin),
      y: rnd(margin, innerHeight - margin),
      r: 10,
      color: Math.random() < .5 ? '#7dd3fc' : '#a7f3d0'
    });
  }
  function updateCollect() {
    if (dots.length < 12 && Math.random() < 0.02) spawnDot();
    [p1, p2].forEach(p=>{
      for (const d of dots) {
        const r2 = (p.r + d.r) ** 2;
        if (dist2(p, d) <= r2) {
          d.x = -9999;
          p.score += 1;
          renderScores();
          if (p.score >= GOAL_COLLECT && !world.roundOver) {
            world.roundOver = true; showMsg(`${p===p1?'P1':'P2'} collected ${GOAL_COLLECT}!`);
          }
        }
      }
    });
    dots = dots.filter(d => d.x !== -9999);
  }

  function updateSumo() {
    [p1,p2].forEach(p=>{
      const dx = p.x - arena.x, dy = p.y - arena.y;
      const d = Math.hypot(dx,dy);
      const limit = arena.r - p.r;
      if (d > limit) {
        const nx = dx / d, ny = dy / d;
        p.x = arena.x + nx * limit;
        p.y = arena.y + ny * limit;
        if (d > arena.r + p.r*0.25 && !world.roundOver) {
          world.roundOver = true;
          const winner = (p===p1) ? 'P2' : 'P1';
          (p===p1 ? p2 : p1).score += 1;
          renderScores();
          showMsg(`${winner} wins the push!`);
        }
      }
    });
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const d = Math.hypot(dx,dy);
    const minDist = p1.r + p2.r;
    if (d > 0 && d < minDist) {
      const overlap = (minDist - d) / 2;
      const nx = dx / d, ny = dy / d;
      p1.x -= nx * overlap; p1.y -= ny * overlap;
      p2.x += nx * overlap; p2.y += ny * overlap;
      p1.vx -= nx * 40; p1.vy -= ny * 40;
      p2.vx += nx * 40; p2.vy += ny * 40;
    }
  }

  // ===== MAZE generation & movement =====
  function generateMaze() {
    const targetCols = clamp(Math.floor(innerWidth / 28), 20, 42);
    maze.size = Math.max(24, Math.min(34, Math.floor(innerWidth / targetCols)));
    maze.lineWidth = Math.max(3, Math.floor(maze.size * 0.14));
    maze.pad = Math.max(12, Math.floor(Math.min(innerWidth, innerHeight) * 0.04));

    maze.cols = Math.floor((innerWidth - maze.pad*2) / maze.size);
    maze.rows = Math.floor((innerHeight - maze.pad*2) / maze.size);
    maze.cols = Math.max(8, maze.cols);
    maze.rows = Math.max(8, maze.rows);

    maze.walls = Array.from({length: maze.rows}, ()=>Array.from({length: maze.cols}, ()=>({N:true,E:true,S:true,W:true, visited:false})));

    const stack = [];
    let cx = 0, cy = 0;
    const push = (x,y)=>{ stack.push({x,y}); maze.walls[y][x].visited = true; };
    push(cx,cy);

    const dirs = [
      {dx:0,dy:-1, a:'N', b:'S'},
      {dx:1,dy:0,  a:'E', b:'W'},
      {dx:0,dy:1,  a:'S', b:'N'},
      {dx:-1,dy:0, a:'W', b:'E'}
    ];

    while (stack.length) {
      const cur = stack[stack.length-1];
      cx = cur.x; cy = cur.y;
      for (let i=dirs.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [dirs[i],dirs[j]]=[dirs[j],dirs[i]]; }
      let advanced = false;
      for (const d of dirs) {
        const nx = cx + d.dx, ny = cy + d.dy;
        if (nx>=0 && nx<maze.cols && ny>=0 && ny<maze.rows && !maze.walls[ny][nx].visited) {
          maze.walls[cy][cx][d.a] = false;
          maze.walls[ny][nx][d.b] = false;
          push(nx,ny);
          advanced = true;
          break;
        }
      }
      if (!advanced) stack.pop();
    }

    maze.start = {x:0,y:0};
    maze.end   = {x:maze.cols-1,y:maze.rows-1};
    maze.goal  = {x: (maze.cols/2)|0, y: (maze.rows/2)|0};
  }

  function moveInMaze(p, dt) {
    const s = maze.size, ox = maze.pad, oy = maze.pad;
    const toCell = (x,y)=>({ cx: clamp(Math.floor((x-ox)/s), 0, maze.cols-1),
                             cy: clamp(Math.floor((y-oy)/s), 0, maze.rows-1) });
    let nx = p.x + p.vx * dt;
    let ny = p.y + p.vy * dt;

    if (p.vx !== 0) {
      const dir = Math.sign(p.vx);
      const {cx,cy} = toCell(p.x, p.y);
      const cell = maze.walls[cy][cx];
      if (dir > 0 && cell.E) nx = Math.min(nx, ox + (cx+1)*s - p.r - 1);
      if (dir < 0 && cell.W) nx = Math.max(nx, ox + cx*s + p.r + 1);
      const {cx:ncx, cy:ncy} = toCell(nx, p.y);
      if (ncx !== cx || ncy !== cy) {
        const ncell = maze.walls[ncy][ncx];
        if (dir > 0 && ncell.W) nx = Math.max(nx, ox + ncx*s + p.r + 1);
        if (dir < 0 && ncell.E) nx = Math.min(nx, ox + (ncx+1)*s - p.r - 1);
      }
      p.x = nx;
    }
    if (p.vy !== 0) {
      const dir = Math.sign(p.vy);
      const {cx,cy} = toCell(p.x, p.y);
      const cell = maze.walls[cy][cx];
      if (dir > 0 && cell.S) ny = Math.min(ny, oy + (cy+1)*s - p.r - 1);
      if (dir < 0 && cell.N) ny = Math.max(ny, oy + cy*s + p.r + 1);
      const {cx:ncx, cy:ncy} = toCell(p.x, ny);
      if (ncx !== cx || ncy !== cy) {
        const ncell = maze.walls[ncy][ncx];
        if (dir > 0 && ncell.N) ny = Math.max(ny, oy + ncy*s + p.r + 1);
        if (dir < 0 && ncell.S) ny = Math.min(ny, oy + (ncy+1)*s - p.r - 1);
      }
      p.y = ny;
    }

    const minX = ox + p.r + 1, maxX = ox + maze.cols*s - p.r - 1;
    const minY = oy + p.r + 1, maxY = oy + maze.rows*s - p.r - 1;
    p.x = clamp(p.x, minX, maxX);
    p.y = clamp(p.y, minY, maxY);
  }

  function drawMaze() {
    if (!maze.walls) return;
    const s = maze.size, ox = maze.pad, oy = maze.pad;
    ctx.save();
    ctx.lineWidth = maze.lineWidth;
    ctx.strokeStyle = 'rgba(232,236,255,0.85)';
    ctx.lineCap = 'square';
    ctx.beginPath();
    ctx.rect(ox, oy, maze.cols*s, maze.rows*s);
    ctx.stroke();
    ctx.beginPath();
    for (let y=0; y<maze.rows; y++) {
      for (let x=0; x<maze.cols; x++) {
        const w = maze.walls[y][x];
        const px = ox + x*s, py = oy + y*s;
        if (w.N) { ctx.moveTo(px, py); ctx.lineTo(px+s, py); }
        if (w.E) { ctx.moveTo(px+s, py); ctx.lineTo(px+s, py+s); }
        if (w.S) { ctx.moveTo(px, py+s); ctx.lineTo(px+s, py+s); }
        if (w.W) { ctx.moveTo(px, py); ctx.lineTo(px, py+s); }
      }
    }
    ctx.stroke();
    const gx = ox + maze.goal.x*s + s/2;
    const gy = oy + maze.goal.y*s + s/2;
    drawStar(gx, gy, Math.max(8, Math.floor(s*0.28)), 5);
    ctx.restore();
  }

  // ===== Bomber: arena build =====
  function buildBomberArena(){
    // Choose tile size to fit nicely
    const targetCols = clamp(Math.floor(innerWidth / 40), 13, 19);
    bomber.tile = Math.floor(innerWidth / targetCols);
    bomber.cols = clamp(targetCols, 11, 21);
    // rows based on height
    bomber.rows = clamp(Math.floor((innerHeight - 120) / bomber.tile), 9, 17);

    // center offset
    bomber.ox = Math.floor((innerWidth - bomber.cols*bomber.tile)/2);
    bomber.oy = Math.floor((innerHeight - bomber.rows*bomber.tile)/2);

    // Build grid
    bomber.grid = Array.from({length:bomber.rows}, (_,y)=>Array.from({length:bomber.cols}, (_,x)=>{
      // Border solid
      if (y===0 || y===bomber.rows-1 || x===0 || x===bomber.cols-1) return 1;
      // Checker indestructible pillars
      if (x%2===0 && y%2===0) return 1;
      // Will decide crates later
      return 0;
    }));

    // Place crates (not in safe spawn corridors)
    for (let y=1;y<bomber.rows-1;y++){
      for (let x=1;x<bomber.cols-1;x++){
        if (bomber.grid[y][x]!==0) continue;
        // keep spawn safe zones (2x2 around corners)
        const inP1Safe = (x<=2 && y<=2);
        const inP2Safe = (x>=bomber.cols-3 && y>=bomber.rows-3);
        if (inP1Safe || inP2Safe) continue;
        if (chance(0.6)) bomber.grid[y][x]=2; // crate
      }
    }

    bomber.powerups = [];
    bomber.bombs = [];
    bomber.flames = [];
    bomber.sdTimer = 0; bomber.ring = 0;
  }

  // Tile helpers
  function pxToCell(px, py){
    const cx = Math.floor((px - bomber.ox) / bomber.tile);
    const cy = Math.floor((py - bomber.oy) / bomber.tile);
    return {x: clamp(cx,0,bomber.cols-1), y: clamp(cy,0,bomber.rows-1)};
  }
  function cellCenter(cx, cy){
    return {
      x: bomber.ox + cx*bomber.tile + bomber.tile/2,
      y: bomber.oy + cy*bomber.tile + bomber.tile/2
    };
  }

  function cellBlocked(cx, cy, ignoreBombPass=false){
    if (cx<0||cy<0||cx>=bomber.cols||cy>=bomber.rows) return true;
    if (bomber.grid[cy][cx]===1) return true; // solid
    if (bomber.grid[cy][cx]===2) return true; // crate blocks movement
    // bombs block unless pass-through
    const bombHere = bomber.bombs.find(b=>b.x===cx && b.y===cy);
    if (bombHere && !(ignoreBombPass)) return true;
    return false;
  }

  // Tight AABB move for bomber mode
  function moveInBomber(p, dt){
    const speed = p.maxSpeed * (1 + p.speedBoost*0.12);
    p.vx = (p.targetX) * 0.9; // damp
    p.vy = (p.targetY) * 0.9;

    let nx = p.x + p.vx * dt;
    let ny = p.y + p.vy * dt;

    // radius safety
    const r = Math.min(p.r, bomber.tile*0.4);

    // resolve X
    if (p.vx !== 0){
      const dir = Math.sign(p.vx);
      // sample ahead at upper/mid/lower points
      const samples = [-r*0.6, 0, r*0.6];
      let blocked = false;
      for (const sy of samples){
        const cx = Math.floor(( (nx + dir*r) - bomber.ox ) / bomber.tile);
        const cy = Math.floor(( (p.y + sy) - bomber.oy ) / bomber.tile);
        if (cellBlocked(cx, cy, p.canPass)) { blocked = true; break; }
      }
      if (blocked){
        // snap to cell boundary
        const cc = pxToCell(p.x, p.y);
        const edge = dir>0 ? (bomber.ox + (cc.x+1)*bomber.tile) : (bomber.ox + cc.x*bomber.tile);
        nx = edge - dir*r - 0.01*dir;
      }
      p.x = nx;
    }
    // resolve Y
    if (p.vy !== 0){
      const dir = Math.sign(p.vy);
      const samples = [-r*0.6, 0, r*0.6];
      let blocked = false;
      for (const sx of samples){
        const cx = Math.floor(( (p.x + sx) - bomber.ox ) / bomber.tile);
        const cy = Math.floor(( (ny + dir*r) - bomber.oy ) / bomber.tile);
        if (cellBlocked(cx, cy, p.canPass)) { blocked = true; break; }
      }
      if (blocked){
        const cc = pxToCell(p.x, p.y);
        const edge = dir>0 ? (bomber.oy + (cc.y+1)*bomber.tile) : (bomber.oy + cc.y*bomber.tile);
        ny = edge - dir*r - 0.01*dir;
      }
      p.y = ny;
    }

    // collect powerup if centered in tile
    const c = pxToCell(p.x, p.y);
    const puIdx = bomber.powerups.findIndex(u=>u.x===c.x && u.y===c.y);
    if (puIdx>=0){
      const u = bomber.powerups[puIdx];
      if (u.type==='bomb' && p.bombsMax<4) { p.bombsMax++; p.bombsCarried++; }
      else if (u.type==='range' && p.flame<6) p.flame++;
      else if (u.type==='speed' && p.speedBoost<3) p.speedBoost++;
      else if (u.type==='kick') p.canKick = true;
      else if (u.type==='pass') p.canPass = true;
      bomber.powerups.splice(puIdx,1);
    }

    // Kicking bombs
    if (p.canKick){
      const b = bomber.bombs.find(b=>b.x===c.x && b.y===c.y);
      if (b && !b.moving){
        const dx = Math.sign(p.vx || p.targetX);
        const dy = Math.sign(p.vy || p.targetY);
        if (dx!==0 || dy!==0){
          // slide until obstacle or bomb
          let sx = b.x, sy = b.y;
          while(true){
            const nx = sx+dx, ny = sy+dy;
            if (cellBlocked(nx, ny)) break;
            if (bomber.bombs.find(ob=>ob!==b && ob.x===nx && ob.y===ny)) break;
            sx = nx; sy = ny;
            // stop if next is obstacle
            if (cellBlocked(sx+dx, sy+dy)) break;
          }
          if (sx!==b.x || sy!==b.y){
            b.moving = {dx,dy};
          }
        }
      }
    }
  }

  function placeBomb(player){
    if (world.mode !== MODE.BOMBER || world.roundOver) return;
    if (player.bombsCarried <= 0 || player.bombCooldown>0) return;
    const c = pxToCell(player.x, player.y);
    // tile must be empty of bomb and passable
    if (cellBlocked(c.x, c.y, true)) return;
    if (bomber.bombs.find(b=>b.x===c.x && b.y===c.y)) return;
    bomber.bombs.push({
      x:c.x, y:c.y, owner:player, fuse:1.8, range:player.flame,
      solidAt: 0.15, moving:null
    });
    player.bombsCarried--;
    player.bombCooldown = 0.12; // small anti-spam
  }

  function detonateBomb(b){
    // create flames at center and in four directions up to range
    const visited = [];
    const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
    const pushFlame = (x,y)=>{ bomber.flames.push({x,y,t:0.28}); visited.push(x+','+y); };
    pushFlame(b.x,b.y);

    for (const d of dirs){
      for (let i=1;i<=b.range;i++){
        const cx = b.x + d.dx*i, cy = b.y + d.dy*i;
        if (cx<=0||cy<=0||cx>=bomber.cols-1||cy>=bomber.rows-1) break;
        const cell = bomber.grid[cy][cx];
        if (cell===1) break; // solid stops
        pushFlame(cx,cy);
        if (cell===2){ // crate destroyed and stop
          bomber.grid[cy][cx]=0;
          // chance to spawn a powerup
          if (chance(0.25)){
            const types = ['bomb','range','speed','kick','pass'];
            const type = types[(Math.random()*types.length)|0];
            bomber.powerups.push({x:cx,y:cy,type});
          }
          break;
        }
        // keep going through empty
      }
    }
    // chain reaction: ignite nearby bombs in flames
    for (const ob of bomber.bombs){
      if (ob===b) continue;
      if (visited.includes(ob.x+','+ob.y)) ob.fuse = Math.min(ob.fuse, 0.02);
    }
  }

  function updateBombs(dt){
    for (const b of bomber.bombs){
      // movement (kicked)
      if (b.moving){
        const nx = b.x + b.moving.dx;
        const ny = b.y + b.moving.dy;
        if (cellBlocked(nx, ny) || bomber.bombs.find(ob=>ob!==b && ob.x===nx && ob.y===ny)){
          b.moving = null;
        } else { b.x = nx; b.y = ny; }
      }
      b.fuse -= dt;
      b.solidAt -= dt;
    }
    // explode
    const toExplode = bomber.bombs.filter(b=>b.fuse<=0);
    if (toExplode.length){
      for (const b of toExplode) detonateBomb(b);
      // return carried bombs to owners
      for (const b of toExplode) b.owner.bombsCarried = Math.min(b.owner.bombsCarried+1, b.owner.bombsMax);
    }
    bomber.bombs = bomber.bombs.filter(b=>b.fuse>0);
  }

  function updateFlames(dt){
    // damage players
    for (const f of bomber.flames){
      const cc = cellCenter(f.x,f.y);
      [p1,p2].forEach(p=>{
        if (!p.alive) return;
        const r = p.r * 0.9;
        if ((p.x>cc.x-bomber.tile/2 && p.x<cc.x+bomber.tile/2) &&
            (p.y>cc.y-bomber.tile/2 && p.y<cc.y+bomber.tile/2)){
          // overlaps tile
          p.alive = false;
        }
      });
      f.t -= dt;
    }
    bomber.flames = bomber.flames.filter(f=>f.t>0);
    // resolve deaths
    if (!world.roundOver){
      const aliveCount = (p1.alive?1:0)+(p2.alive?1:0);
      if (aliveCount<=1){
        world.roundOver = true;
        let winner = 'Draw';
        if (p1.alive && !p2.alive){ winner='P1'; p1.score++; }
        else if (p2.alive && !p1.alive){ winner='P2'; p2.score++; }
        renderScores();
        const champ = (p1.score>=bomber.roundWinsTo || p2.score>=bomber.roundWinsTo);
        showMsg(champ? `${winner} wins the match!` : `${winner} wins the round!`);
      }
    }
  }

  function updateSuddenDeath(dt){
    bomber.sdTimer += dt;
    if (bomber.sdTimer < bomber.suddenDeathAt) return;
    // every 3 seconds add a ring of solid from borders inward
    const step = 3.0;
    const phase = Math.floor((bomber.sdTimer - bomber.suddenDeathAt)/step)+1;
    if (phase <= bomber.ring) return;
    bomber.ring = phase;

    const ring = bomber.ring;
    const minX = ring, minY = ring, maxX = bomber.cols-1-ring, maxY = bomber.rows-1-ring;
    if (minX >= maxX || minY >= maxY) return;

    for (let x=minX; x<=maxX; x++){
      if (bomber.grid[minY][x]===0) bomber.grid[minY][x]=1;
      if (bomber.grid[maxY][x]===0) bomber.grid[maxY][x]=1;
    }
    for (let y=minY; y<=maxY; y++){
      if (bomber.grid[y][minX]===0) bomber.grid[y][minX]=1;
      if (bomber.grid[y][maxX]===0) bomber.grid[y][maxX]=1;
    }
  }

  // ===== Rendering =====
  function drawGrid() {
    const s = 40; ctx.save(); ctx.strokeStyle='rgba(255,255,255,.05)'; ctx.lineWidth=1;
    for (let x=0;x<innerWidth;x+=s){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,innerHeight); ctx.stroke(); }
    for (let y=0;y<innerHeight;y+=s){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(innerWidth,y); ctx.stroke(); }
    ctx.restore();
  }
  function drawSmiley(p) {
    const r = p.r, x = p.x, y = p.y;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
    const grd = ctx.createRadialGradient(x - r*0.4, y - r*0.4, r*0.2, x, y, r);
    if (p===p1){ grd.addColorStop(0, '#bfe0ff'); grd.addColorStop(1, '#6ea8fe'); }
    else { grd.addColorStop(0, '#ffd7a3'); grd.addColorStop(1, '#f59e0b'); }
    ctx.fillStyle = grd; ctx.fill();
    ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.stroke();
    ctx.fillStyle='#1a1a1a';
    ctx.beginPath(); ctx.arc(x - r*0.35, y - r*0.2, r*0.12, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + r*0.35, y - r*0.2, r*0.12, 0, Math.PI*2); ctx.fill();
    const spd = Math.hypot(p.vx, p.vy);
    const smile = Math.min(0.7, 0.2 + spd / Math.max(1,p.maxSpeed) * 0.5);
    ctx.strokeStyle='#1a1a1a'; ctx.lineWidth=3; ctx.beginPath();
    const mW = r*0.9, mH = r*smile*0.6;
    ctx.moveTo(x - mW/2, y + r*0.2);
    ctx.quadraticCurveTo(x, y + r*0.2 + mH, x + mW/2, y + r*0.2);
    ctx.stroke();
  }
  function drawBullets() {
    ctx.save(); ctx.fillStyle='#e8ecff';
    for (const b of bullets) { ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
  function drawDots() {
    for (const d of dots) {
      ctx.fillStyle = d.color; ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,Math.PI*2); ctx.fill();
    }
  }
  function drawArena() {
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.arc(arena.x, arena.y, arena.r, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  function drawStar(x, y, r, spikes) {
    const outer = r, inner = r*0.5;
    let rot = Math.PI/2 * 3, step = Math.PI / spikes;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x, y - outer);
    for (let i=0;i<spikes;i++){
      let cx = x + Math.cos(rot) * outer;
      let cy = y + Math.sin(rot) * outer;
      ctx.lineTo(cx, cy);
      rot += step;
      cx = x + Math.cos(rot) * inner;
      cy = y + Math.sin(rot) * inner;
      ctx.lineTo(cx, cy);
      rot += step;
    }
    ctx.lineTo(x, y - outer);
    ctx.closePath();
    ctx.fillStyle = '#ffd54d';
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 2;
    ctx.fill(); ctx.stroke();
    ctx.restore();
  }

  // Bomber draw
  function drawBomber(){
    const t = bomber.tile, ox = bomber.ox, oy = bomber.oy;
    // soft board background
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(ox, oy, bomber.cols*t, bomber.rows*t);

    // grid background
    for (let y=0;y<bomber.rows;y++){
      for (let x=0;x<bomber.cols;x++){
        const px = ox + x*t, py = oy + y*t;
        // floor
        ctx.fillStyle = (x+y)%2===0 ? 'rgba(255,255,255,0.02)' : 'rgba(255,255,255,0.04)';
        ctx.fillRect(px, py, t, t);

        const cell = bomber.grid[y][x];
        if (cell===1){
          // solid
          ctx.fillStyle = '#1a244b';
          ctx.fillRect(px+2, py+2, t-4, t-4);
          ctx.strokeStyle = 'rgba(255,255,255,0.08)';
          ctx.strokeRect(px+2, py+2, t-4, t-4);
        } else if (cell===2){
          // crate
          ctx.fillStyle = '#3a2b18';
          ctx.fillRect(px+3, py+3, t-6, t-6);
          ctx.strokeStyle = 'rgba(255,255,255,0.06)';
          ctx.strokeRect(px+3, py+3, t-6, t-6);
          // slats
          ctx.strokeStyle = 'rgba(0,0,0,0.35)';
          ctx.beginPath();
          ctx.moveTo(px+4, py+ t*0.33); ctx.lineTo(px+t-4, py+t*0.33);
          ctx.moveTo(px+4, py+ t*0.66); ctx.lineTo(px+t-4, py+t*0.66);
          ctx.stroke();
        }
      }
    }

    // powerups
    for (const u of bomber.powerups){
      const cc = cellCenter(u.x,u.y);
      ctx.save();
      ctx.translate(cc.x, cc.y);
      ctx.beginPath(); ctx.arc(0,0,t*0.22,0,Math.PI*2);
      const mapColor = {
        bomb:'#7dd3fc', range:'#a7f3d0', speed:'#fde68a', kick:'#c7d2fe', pass:'#fca5a5'
      };
      ctx.fillStyle = mapColor[u.type] || '#e8ecff';
      ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle='rgba(0,0,0,.3)'; ctx.stroke();
      ctx.fillStyle='#0b1020'; ctx.font = 'bold '+Math.floor(t*0.25)+'px system-ui';
      const label = {bomb:'B',range:'R',speed:'S',kick:'K',pass:'P'}[u.type]||'?';
      ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(label,0,1);
      ctx.restore();
    }

    // bombs
    for (const b of bomber.bombs){
      const cc = cellCenter(b.x,b.y);
      ctx.save();
      ctx.translate(cc.x, cc.y);
      ctx.beginPath(); ctx.arc(0,0,t*0.22,0,Math.PI*2);
      ctx.fillStyle = '#222833';
      ctx.fill();
      // fuse
      ctx.beginPath(); ctx.arc(0,-t*0.18, t*0.07, 0, Math.PI*2); ctx.fillStyle='#555b6b'; ctx.fill();
      // flicker
      ctx.fillStyle = b.fuse<0.5 ? '#ffd54d' : 'rgba(255,213,77,0.7)';
      ctx.fillRect(-2,-t*0.27,4,8);
      ctx.restore();
    }

    // flames
    for (const f of bomber.flames){
      const cc = cellCenter(f.x,f.y);
      const alpha = clamp(f.t/0.28,0,1);
      ctx.save();
      ctx.globalAlpha = 0.9*alpha;
      const g = ctx.createRadialGradient(cc.x, cc.y, 4, cc.x, cc.y, t*0.45);
      g.addColorStop(0, 'rgba(255,240,170,1)');
      g.addColorStop(1, 'rgba(255,120,60,0.1)');
      ctx.fillStyle = g;
      ctx.fillRect(cc.x - t/2 +2, cc.y - t/2 +2, t-4, t-4);
      ctx.restore();
    }

    ctx.restore();
  }

  // ===== Round/messages =====
  function showMsg(text) {
    ui.msg.textContent = text + ' ‚Äî Tap Reset';
    ui.msg.style.display = 'block';
  }

  // ===== Main loop =====
  let last = performance.now();
  function frame(now){
    const dt = Math.min(0.035, (now-last)/1000); last = now;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if (!world.paused && !world.roundOver) {
      updateTargets();

      // accelerate toward target velocity (arcade modes)
      [p1,p2].forEach(p=>{
        const ax = (p.targetX - p.vx) * p.accel * dt;
        const ay = (p.targetY - p.vy) * p.accel * dt;
        p.vx += ax; p.vy += ay;
        if (Math.abs(p.targetX)+Math.abs(p.targetY) < 1) { p.vx *= p.friction; p.vy *= p.friction; }
      });

      if (world.mode === MODE.MAZE) {
        drawMaze();
        moveInMaze(p1, dt);
        moveInMaze(p2, dt);
        checkMazeGoal();
      } else if (world.mode === MODE.BOMBER){
        drawBomber();
        moveInBomber(p1, dt);
        moveInBomber(p2, dt);
        updateBombs(dt);
        updateFlames(dt);
        updateSuddenDeath(dt);
        // cooldowns
        p1.bombCooldown = Math.max(0, p1.bombCooldown - dt);
        p2.bombCooldown = Math.max(0, p2.bombCooldown - dt);
      } else {
        // Arcade field
        drawGrid();
        updatePlayer(p1, dt);
        updatePlayer(p2, dt);

        if (world.mode === MODE.DODGE) {
          tryFire(p1); tryFire(p2);
          updateBullets(dt);
          checkBulletHits();
        } else if (world.mode === MODE.COLLECT) {
          updateCollect();
        } else if (world.mode === MODE.SUMO) {
          drawArena();
          updateSumo();
        }
      }
    } else {
      if (world.mode === MODE.SUMO) drawArena();
      if (world.mode === MODE.MAZE) drawMaze();
      if (world.mode === MODE.BOMBER) drawBomber();
    }

    if (world.mode === MODE.COLLECT) drawDots();
    if (world.mode === MODE.DODGE) drawBullets();
    drawSmiley(p1); drawSmiley(p2);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ===== MAZE goal check =====
  const MAZE_GOAL_WIN = 3;
  function checkMazeGoal() {
    const s = maze.size, ox = maze.pad, oy = maze.pad;
    const gx = ox + maze.goal.x*s + s/2;
    const gy = oy + maze.goal.y*s + s/2;
    const gr = Math.max(10, Math.floor(s*0.32));
    const r1 = (p1.r + gr), r2 = (p2.r + gr);
    const hit1 = ((p1.x-gx)**2 + (p1.y-gy)**2) <= r1*r1;
    const hit2 = ((p2.x-gx)**2 + (p2.y-gy)**2) <= r2*r2;

    if (!hit1 && !hit2) return;
    let winner = null;
    if (hit1 && !hit2) winner = 'P1';
    else if (!hit1 && hit2) winner = 'P2';
    else {
      const d1 = Math.hypot(p1.x-gx, p1.y-gy);
      const d2 = Math.hypot(p2.x-gx, p2.y-gy);
      winner = (d1 <= d2) ? 'P1' : 'P2';
    }

    if (winner === 'P1') p1.score += 1; else p2.score += 1;
    renderScores();

    if ((p1.score >= MAZE_GOAL_WIN || p2.score >= MAZE_GOAL_WIN) && !world.roundOver) {
      world.roundOver = true;
      showMsg(`${winner} wins the match!`);
      return;
    }
    generateMaze();
    resetCommonPositions();
  }

  // ===== Physics & update for arcade modes =====
  function updatePlayer(p, dt) {
    const ax = (p.targetX - p.vx) * p.accel * dt;
    const ay = (p.targetY - p.vy) * p.accel * dt;
    p.vx += ax; p.vy += ay;
    if (Math.abs(p.targetX)+Math.abs(p.targetY) < 1) { p.vx *= p.friction; p.vy *= p.friction; }
    p.x += p.vx * dt; p.y += p.vy * dt;

    if (world.mode !== MODE.SUMO) {
      const r = p.r;
      const maxX = innerWidth - r, maxY = innerHeight - r;
      if (p.x < r){ p.x=r; if(p.vx<0) p.vx=0; }
      if (p.y < r){ p.y=r; if(p.vy<0) p.vy=0; }
      if (p.x > maxX){ p.x=maxX; if(p.vx>0) p.vx=0; }
      if (p.y > maxY){ p.y=maxY; if(p.vy>0) p.vy=0; }
    }
    p.fireCd = Math.max(0, p.fireCd - dt);
  }

  // ===== UI events =====
  ui.modeSel.addEventListener('change', (e)=> resetMode(e.target.value));
  ui.resetBtn.addEventListener('click', ()=> resetMode(world.mode));
  ui.pauseBtn.addEventListener('click', ()=>{
    world.paused = !world.paused;
    ui.pauseBtn.textContent = world.paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
    ui.pauseBtn.setAttribute('aria-pressed', String(world.paused));
  });

  // Bomb buttons
  ui.bombL.addEventListener('click', ()=> placeBomb(p1));
  ui.bombR.addEventListener('click', ()=> placeBomb(p2));

  // Desktop controls
  const keys = new Set();
  addEventListener('keydown', (e)=>{
    keys.add(e.code);
    if (world.mode===MODE.BOMBER){
      if (e.code==='Space'){ placeBomb(p1); e.preventDefault(); }
      if (e.code==='Enter'){ placeBomb(p2); e.preventDefault(); }
    }
  }, {passive:false});
  addEventListener('keyup', (e)=>{ keys.delete(e.code); }, {passive:true});

  function pollKeys(){
    // P1 WASD
    let lx = 0, ly = 0;
    if (keys.has('KeyA')) lx -= 1;
    if (keys.has('KeyD')) lx += 1;
    if (keys.has('KeyW')) ly -= 1;
    if (keys.has('KeyS')) ly += 1;
    // P2 arrows
    let rx = 0, ry = 0;
    if (keys.has('ArrowLeft')) rx -= 1;
    if (keys.has('ArrowRight')) rx += 1;
    if (keys.has('ArrowUp')) ry -= 1;
    if (keys.has('ArrowDown')) ry += 1;

    if (lx||ly){ const d = Math.hypot(lx,ly)||1; stickL.x = lx/d; stickL.y = ly/d; }
    if (rx||ry){ const d = Math.hypot(rx,ry)||1; stickR.x = rx/d; stickR.y = ry/d; }
    requestAnimationFrame(pollKeys);
  }
  requestAnimationFrame(pollKeys);

  // initial
  resetMode(MODE.BOMBER); // Start in Bomber for quick testing; change to MODE.DODGE if you prefer.
})();
</script>
</body>
</html>
